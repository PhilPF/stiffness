/* taylor Version 2.1, May 26, 2023 */
/* Using coef lib: MY_FLOAT */
/* Using jet lib: jet_tree. m symbol, degree n */
#include "taylor.h"

/***********************************************************************
 *
 * Code generated by the TAYLOR translator.
 */

#define _N_DIM_ 3
#define _J_DIM_ 3


#define xInitUpJet InitUpJet
#define xInitJet InitJet
#define xNormJet NormJet
#define xMultiplyFloatJetA MultiplyFloatJetA
#define xAddJetJetA AddJetJetA 
#define xAssignJetToJet AssignJetToJet
#define xAssignJetToFloat AssignJetToFloat





/*
next line defines the largest power of 2 such that 2^(LEXP2) and
2^(-LEXP2) do not overflow/underflow the double arithmetic of your
computer.
*/
#define LEXP2 1023 

#define DEBUG_LEVEL 0 /* to print some internal information */

int taylor_step_taylor(MY_FLOAT *ti,
                 MY_FLOAT *x,
                 int      dir,
                 int      step_ctl,
                 double   log10abserr,
                 double   log10relerr,
                 MY_FLOAT *endtime,
                 MY_FLOAT *ht,
                 int      *order,
                 MY_JET   *jetInOut)
/*
 * single integration step with taylor method. the parameters are:
 *
 * ti: on input:  time of the initial condition
 *     on output: new time
 *
 * x:  on input:  initial condition
 *     on output: new condition, corresponding to the (output) time ti
 *
 * dir: flag to integrate forward or backwards.
 *     1: forward
 *    -1: backwards
 *     WARNING: this flag is ignored if step_ctl (see below) is set to 0.
 *
 * step_ctl: flag for the step size control. the possible values are:
 *     0: no step size control, so the step and order are provided by
 *        the user. the parameter ht is used as step, and the parameter
 *        order (see below) is used as the order.
 *     1: standard stepsize control. it uses an approximation to the
 *        optimal order and to the radius of convergence of the series
 *        to approximate the 'optimal' step size. It tries to keep
 *        either the absolute or the relative errors below the given
 *        values. See the paper for more details.
 *     2: as 1, but adding an extra condition on the stepsize h: the
 *        terms of the series --after being multiplied by the suitable
 *        power of h-- cannot grow.
 *    -1: user defined stepsize control. the code has to be included
 *        in the routine compute_timestep_user_defined (you can find
 *        this routine below). The user should also provide code for
 *        the selection of degree (see the function
 *        compute_order_user_defined below).
 *
 * log10abserr: decimal log of the absolute accuracy. the routine
 *     tries to keep either the absolute or the relative errors below
 *     the given thresholds.
 *
 * log10relerr: decimal log of the relative accuracy. the routine
 *     tries to keep either the absolute or the relative errors below
 *     the given thresholds.
 *
 * endtime: if NULL, it is ignored. if step_ctl (see above) is set
 *     to 0, it is also ignored. otherwise, if the step size is too
 *     large, it is reduced so that the new time ti is exactly endtime
 *     (in that case, the function returns 1).
 *
 * ht: on input:  ignored/used as a time step (see parameter step_ctl)
 *     on output: time step used if the pointer is not NULL
 *
 * order: degree of the taylor expansion.
 *        input: this parameter is only used if step_ctl is 0,
 *               or if you add the code for the case step_ctl=3.
 *               its possible values are:
 *               < 2: the program will select degree 2 (if step_ctl is 0).
 *               >=2: the program will use this degree (if step_ctl is 0).
 *        ouput: degree used if the pointer is not NULL
 *
 * jetInOut: on input: the value of all declared jet variables
 *           on output: new value of the jet variable, corresponding to the new time
 *
 * return value:
 *  0: ok.
 *  1: ok, and ti=endtime.  
 * -1: not ok, unable to compute step size.  double_log  underflow/overflow  */
{
  MY_FLOAT **taylor_coefficients_taylor(MY_FLOAT, MY_FLOAT*, int);
  MY_FLOAT **taylor_coefficients_taylorA(MY_FLOAT, MY_FLOAT*, int, int);
  int compute_order_1_taylor(double, double, double, int*);
  int comp_order_other_taylor(double, double, double);
  double compute_stepsize_1_taylor(MY_FLOAT**, MY_JET**, int, double, int);
  double compute_stepsize_2_taylor(MY_FLOAT**, MY_JET**, int, double, int);
  double comp_stepsize_other_taylor(MY_FLOAT**, MY_JET**, int, int, double, double, double);

  static MY_FLOAT **s,h,mtmp;
  static MY_JET jtmp,jtmp1, **jetJetOut;
  double xi,xnorm,dh;
  int i,j,k,nt,flag_endtime,flag_err;
  static int init=0;
#pragma omp threadprivate(s,h,mtmp,init)
#pragma omp threadprivate(jtmp,jtmp1,jetJetOut)

  if (init == 0) /* initialization of MY_FLOAT and MY_JET variables */
    {
      init=1;
      InitMyFloat(h);
      InitMyFloat(mtmp);
      xInitUpJet();
      xInitJet(jtmp);
      xInitJet(jtmp1);
    }
/*
  sup norm of the initial condition (jet included)
*/
  xnorm=0;
  if (step_ctl != 0)
    {
#if _J_DIM_ != 0
    for (i=0; i<_J_DIM_; i++)
      {
        xNormJet(mtmp,jetInOut[i]);
        MyFloatToDouble(xi,mtmp);
        xi=fabs(xi);
        if (xi > xnorm) xnorm=xi;
      }
#endif
      for (i=_J_DIM_; i<_N_DIM_; i++)
      {
        MyFloatToDouble(xi,x[i]);
        xi=fabs(xi);
        if (xi > xnorm) xnorm=xi;
      }
    }
/*
  we determine the degree of the taylor expansion.
  this value will be stored in the variable nt.
  the flag flag_err returns a value indicating if we are using an
  absolute error estimate (value 1) or a relative one (value 2).
*/
  switch(step_ctl)
    {
    case 0: /* no step size control, fixed degree; both given by the user */
      if (order==NULL)
      {
        fprintf(stderr,"step_ctl=%d needs an input order\n",step_ctl);
        exit(0);
      }
      nt=(*order<2)? 2: *order; /* 2 is the minimum order allowed */
      break;
    case 1:
      nt=compute_order_1_taylor(xnorm,log10abserr,log10relerr,&flag_err);
      break;
    case 2:
      nt=compute_order_1_taylor(xnorm,log10abserr,log10relerr,&flag_err);
      break;
    case -1:
      nt=comp_order_other_taylor(xnorm,log10abserr,log10relerr);
      break;
    default:
      fprintf(stderr, "taylor_step: undefined step size control.\n");
      fprintf(stderr, "you must choose an existing step size control\n");
      fprintf(stderr, "method or supply a step size control procedure.\n");
      exit(0);
    }
  if (order!=NULL) *order=nt;
/*
  computation of the jet of derivatives up to order nt
*/
  if(step_ctl != 0) {
    s=taylor_coefficients_taylor_A(*ti,x,nt,1, jetInOut, &jetJetOut);
  } else {
    s=taylor_coefficients_taylor_A(*ti,x,nt,0, jetInOut, &jetJetOut); 
 }

/*
  selection of the routine to compute the time step. the value
  step_ctl=3 has been reserved for the user, in case she/he wants to
  code a different method.
*/
  dh=1.0;
  switch(step_ctl)
    {
    case 0: /* no step size control (fixed step size, given by the user) */
      if (ht==NULL)
      {
        fprintf(stderr,"step_ctl=%d needs an input stepsize\n",step_ctl);
        exit(0);
      }
      AssignMyFloat(h,*ht);
      break;
    case 1:
      dh=compute_stepsize_1_taylor(s,jetJetOut,nt,xnorm,flag_err);
      MakeMyFloatA(h, dh);
      break;
    case 2:
      dh=compute_stepsize_2_taylor(s,jetJetOut,nt,xnorm,flag_err);
      MakeMyFloatA(h, dh);
      break;
    case -1:
      dh=comp_stepsize_other_taylor(s,jetJetOut,_N_DIM_,nt,xnorm,log10abserr,log10relerr);
      MakeMyFloatA(h, dh);
      break;
    default:
      fprintf(stderr, "taylor_step: undefined step size control.\n");
      fprintf(stderr, "You must choose an existing step size control\n");
      fprintf(stderr, "method or supply a step size control procedure.\n");
      exit(0);
    }
  if(dh == 0.0) return -1; //changeme
/*
  if step_ctl != 0, we adjust the sign of the computed stepsize.
*/
  flag_endtime=0;
  if (step_ctl != 0)
    {
      if (dir == -1) { NegateMyFloatA(mtmp,h); AssignMyFloat(h, mtmp);} 
/*
      we compare *ti+h with endtime. we modify h if necessary.
*/
      if (endtime != NULL)
        {
          AddMyFloatA(mtmp,h,*ti);
          if (dir == 1) /* time goes forward */
            {
              if (MyFloatA_GE_B(mtmp,*endtime))
                {
                  SubtractMyFloatA(h,*endtime,*ti);
                  flag_endtime=1;
                }
            }
            else /* time goes backwards */
            {
              if (MyFloatA_GE_B(*endtime,mtmp))
                {
                  SubtractMyFloatA(h,*endtime,*ti);
                  flag_endtime=1;
                }
            }
        }
    }
/*
  next lines are the summation of the taylor series (horner's method)
*/
  j=nt-1;
#if _J_DIM_ != 0
  for(i=0; i<_J_DIM_; i++)
  {
    xAssignJetToJet(jetInOut[i],jetJetOut[i][nt]);
    for(k=j; k>=0; k--)
    {
      xMultiplyFloatJetA(jtmp, h, jetInOut[i]);
      xAddJetJetA(jetInOut[i], jtmp, jetJetOut[i][k]);
    }
    xAssignJetToFloat(x[i],jetInOut[i]);
  }
#endif
  for(i=_J_DIM_; i<_N_DIM_; i++)
  {
    AssignMyFloat(x[i],s[i][nt]);
    for(k=j; k>=0; k--)
    {
      MultiplyMyFloatA(mtmp, h, x[i]);
      AddMyFloatA(x[i], mtmp, s[i][k]);
    }
  }
/*
  finally, we set the values of the parameters *ht and *ti.
*/
  if (ht!=NULL) AssignMyFloat(*ht,h);
  if (flag_endtime == 0)
    {
      AssignMyFloat(mtmp, *ti);
      AddMyFloatA(*ti, mtmp, h);
    }
    else
    {
      AssignMyFloat(*ti,*endtime);
    }
  return(flag_endtime);
}
int compute_order_1_taylor(double xnorm, double log10abserr, double log10relerr, int* flag_err)
/*
 * this is to determine the 'optimal' degree of the taylor expansion.
 *
 * parameters:
 * xnorm: norm of the initial condition
 * log10abserr: base-10 log of the absolute error required
 * log10relerr: base-10 log of the relative error required
 * flag_err:    flag. returns 1 if absolute error is used
 *                    returns 2 if relative error is used
 *
 * returned value: 'optimal' degree.
*/
{
  double log10eps,tmp;
  int nt;

  log10eps=log10abserr;
  *flag_err=1;
  if (xnorm != (double)0.0)
    {
      tmp=log10relerr+log10(xnorm);
      if (tmp > log10abserr) {log10eps=log10relerr; *flag_err=2;}
    }
/*
  we use 1.16 for the value 0.5*log(10)=1.151292546497...
*/
  nt=(int)(1.5-1.16*log10eps);
  if (nt < 2) nt=2; /* this is the minimum order accepted */

#if DEBUG_LEVEL > 0
      fprintf(stderr, "taylor_step: order is %d\n",nt);
#endif

  return(nt);
}
double compute_stepsize_1_taylor(MY_FLOAT **s, MY_JET **jet, int nt, double xnorm, int flag_err)
/*
 * it looks for a step size for an expansion up to order nt. this
 * function requires that nt is the value computed by
 * compute_order_1_
 */
{
  double double_log_MyFloat_taylor(MY_FLOAT x);
  static MY_FLOAT z,v1,v2;
  static MY_FLOAT of,uf;
  double lnv1,lnv2,r,lnro1,lnro2,lnro;
  int i;
  static int init=0;
#pragma omp threadprivate(z,v1,v2,of,uf,init)

  if (init == 0)
    {
      init=1;
      InitMyFloat(z);
      InitMyFloat(v1);
      InitMyFloat(v2);
      InitMyFloat(of);
      InitMyFloat(uf);

      r=pow((double)2,(double)LEXP2);
      MakeMyFloatA(of,r);
      r=pow((double)2,(double)(-LEXP2));
      MakeMyFloatA(uf,r);
    }
/*
  we compute the sup norm of the last two coefficients of the taylor
  series, and we store them into v1 and v2.
*/
  MakeMyFloatA(v1,0);
  MakeMyFloatA(v2,0);
#if _J_DIM_ != 0
  for (i=0; i<_J_DIM_; i++)
  {
    xNormJet(z,jet[i][nt-1]);
    if (MyFloatA_GT_B(z,v1)) AssignMyFloat(v1,z);
    xNormJet(z,jet[i][nt]);
    if (MyFloatA_GT_B(z,v2)) AssignMyFloat(v2,z);
  }
#endif
  for(i=_J_DIM_; i<_N_DIM_; i++)
  {
    fabsMyFloatA(z,s[i][nt-1]);
    if (MyFloatA_GT_B(z,v1)) AssignMyFloat(v1,z);
    fabsMyFloatA(z,s[i][nt]);
    if (MyFloatA_GT_B(z,v2)) AssignMyFloat(v2,z);
  }
/*
  computation of the step size. we need the logs of v1 and v2, in
  double precision (there is no need for extended precision). the idea
  is to assign these variables to double variables and then to use the
  standard log function. before doing that, we have to be sure that v1
  can be assigned to a double without under or overflow. for this
  reason we will check for this condition and, if it fails, we will
  call an specific function for this case.
*/
  if (MyFloatA_LE_B(v1,of) && MyFloatA_GE_B(v1,uf))
    {
      MyFloatToDouble(r,v1);
      lnv1=log(r);
    }
    else
    {
      lnv1=double_log_MyFloat_taylor(v1);
    }
  if (MyFloatA_LE_B(v2,of) && MyFloatA_GE_B(v2,uf))
    {
      MyFloatToDouble(r,v2);
      lnv2=log(r);
    }
    else
    {
      lnv2=double_log_MyFloat_taylor(v2);
    }
  if(lnv1 == 65536.0 || lnv2 == 65536.0 ) return 0.0; //changeme
/*
  if flag_err == 2, this means that we are using a relative error control.
*/
  if (flag_err == 2)
    {
      r = -log10(xnorm);
      lnv1 += r;
      lnv2 += r;
    }
 lnro1= -lnv1/(nt-1);
 lnro2= -lnv2/nt;
 lnro=(lnro1 < lnro2)? lnro1: lnro2;

 r=exp(lnro-2-0.7/(nt-1)); /* exp(-0.7/(nt-1)) is a security factor */
  return(r);
}
double compute_stepsize_2_taylor(MY_FLOAT **s, MY_JET **jet, int nt, double xnorm, int flag_err)
/*
 * it looks for a step size for an expansion up to order nt. this
 * function requires that nt is the value computed by
 * compute_order_1_. it also tries to reduce cancellations of big
 * terms in the summation of the taylor series.
 */
{
  double compute_stepsize_1_taylor(MY_FLOAT**, MY_JET**, int, double, int);
  static MY_FLOAT h,hj,r,z,a,normj;
  double c,rtmp,dh;
  int i,j;
  static int init=0;
#pragma omp threadprivate(h,hj,r,z,a,normj,init)

  if (init == 0)
    {
      init=1;
      InitMyFloat(h); 
      InitMyFloat(hj);
      InitMyFloat(r);
      InitMyFloat(z);
      InitMyFloat(a);
      InitMyFloat(normj);
    }
/*
  we compute the step size according to the first algorithm
*/
  dh=compute_stepsize_1_taylor(s,jet,nt,xnorm,flag_err);
  if(dh == 0.0) return  0.0; // changeme
  MakeMyFloatA(h,dh);
/*
  next lines select a value (z), that will be used to control the size
  of the terms of the Taylor series.
*/
  if (flag_err == 1) {
     MakeMyFloatA(z, 1.0);
  } else if (flag_err == 2) {
    MakeMyFloatA(z,xnorm);
  } else
    {
      printf("compute_stepsize_2 internal error. flag_err: %d\n",flag_err);
      exit(1);
    }
/*
  next loop checks if the sup norm of the terms in the Taylor series are
  lower than z. if a term is greater than z, the step size h is reduced.
*/
  MakeMyFloatA(hj,(double)1.0);

  for(j=1; j<=nt; j++)
  {
    MultiplyMyFloatA(r,h,hj);
    AssignMyFloat(hj,r);

    MakeMyFloatC(normj,"0", (double)0);
#if _J_DIM_ != 0
    for (i=0; i<_J_DIM_; i++)
    {
      xNormJet(a,jet[i][j]);
      if (MyFloatA_GT_B(a,normj)) AssignMyFloat(normj,a);
    }
#endif
    for (i=_J_DIM_; i<_N_DIM_; i++)
    {
      fabsMyFloatA(a,s[i][j]);
      if (MyFloatA_GT_B(a,normj)) AssignMyFloat(normj,a);
    }

    MultiplyMyFloatA(r,normj,hj);
    if (MyFloatA_LE_B(r,z)) continue;
/*
    we reduce h (and hj)
*/
    DivideMyFloatA(hj,z,normj);

    DivideMyFloatA(a,r,z);
    MyFloatToDouble(c,a);
    c=pow(c,(double)1.e0/(double)j);
    MakeMyFloatA(a,c);
    DivideMyFloatA(r,h,a);
    AssignMyFloat(h,r);

#if DEBUG_LEVEL > 1
    fprintf(stderr, "order %2d. reducing h from %14.6e to %14.6e\n",j,c*h,h);
#endif
  }

  MyFloatToDouble(rtmp,h);
  return(rtmp);
}

double double_log_MyFloat_taylor(MY_FLOAT x)
/*
 * natural log, in double precision, of a MY_FLOAT positive number.
 */
{
  static MY_FLOAT a,tmp;
  static MY_FLOAT z,of,uf;
  double b,lx;
  int k;
  static int init=0;
#pragma omp threadprivate(a,tmp,z,of,uf,init)

  if (init == 0)
    {
      init=1;
      InitMyFloat(a);
      InitMyFloat(z);
      InitMyFloat(of);
      InitMyFloat(uf);
      InitMyFloat(tmp);

      b=0;
      MakeMyFloatA(z,b);
      b=pow((double)2,(double)LEXP2);
      MakeMyFloatA(of,b);
      b=pow((double)2,(double)(-LEXP2));
      MakeMyFloatA(uf,b);
    }

  if (MyFloatA_EQ_B(x,z))
    {
      puts("double_log_MyFloat error: zero argument");
      puts("(this is because one of the last two terms of your taylor");
      puts(" expansion is exactly zero)");
      /*exit(1);*/
      return 65536.0;
    }

  AssignMyFloat(a,x);

  k=0;
  while(MyFloatA_LT_B(a,uf))
  {
    ++k;
    if(k>3000){fprintf(stderr,"double_log_MyFloat overflow: %d\n", k); /*exit(1);*/ return 65536.0;}
     MultiplyMyFloatA(tmp,a,of);
    AssignMyFloat(a,tmp);
  }
  while(MyFloatA_GT_B(a,of))
  {
    --k;
    if(k<-3000){fprintf(stderr,"double_log_MyFloat underflow: %d\n", k); /*exit(1);*/ return 65536.0;}
     MultiplyMyFloatA(tmp,a,uf);
    AssignMyFloat(a,tmp);
  }

  MyFloatToDouble(b,a);
/*
  lx stands for log(x)
*/
  lx=log(b)-(LEXP2*0.69314718055994530942)*k;

  return(lx);
}


int comp_order_other_taylor(double lnxnorm, double log10abserr, double log10relerr){
  puts("---");
  puts("compute_order_user_defined:");
  puts("you have to code this routine");
  puts("or select a different value for the step_ctl parameter");
  puts("---");
  exit(1);

  return(0);
}
double comp_stepsize_other_taylor(MY_FLOAT **s, MY_JET **jet, int nd, int nt, double xnorm, double log10abserr, double log10relerr) {

  puts("---");
  puts("compute_timestep_user_defined:");
  puts("you have to code this routine");
  puts("or select a different value for the step_ctl parameter");
  puts("---");
  exit(1);
  return((double)0.00001);
}
static int _jet_tree_monomial_counts_taylor_[]  =      {1,3};
static int _jet_tree_monomial_offsets_taylor_[] =      {0,1,4};
/*table for 3 symbols and degree 1*/
static int jet_tree_num_coefs_homogeneous_taylor[] = {\
1, 0, \
1, 1, \
1, 2, \
1, 3, \
};
/* MACROS TO LINK MY_FLOAT WITH MY_JET COEFFICIENTS */
#ifndef myfloat_t
#define myfloat_t          MY_FLOAT

#define myfloat_init       InitMyFloat
#define myfloat_clean      ClearMyFloat

/* assign */
#define myfloat_set        AssignMyFloat
#define myfloat_set_d      MakeMyFloatB
#define myfloat_set_si     MakeMyFloatB
#define myfloat_set_zero(r) MakeMyFloatC(r,"0",0)

/* elemental operations */
#define myfloat_add2       AddMyFloatA
#define myfloat_sub2       SubtractMyFloatA
#define myfloat_mul2       MultiplyMyFloatA
#define myfloat_div2       DivideMyFloatA

#define myfloat_add2_d     AddMyFloatD
#define myfloat_sub2_d     SubtractMyFloatD
#define myfloat_mul2_d     MultiplyMyFloatD
#define myfloat_div2_d     DivideMyFloatD
#define myfloat_d_sub2     SubtractDMyFloat
#define myfloat_d_div2     DivideDMyFloat

#define myfloat_add2_si    AddMyFloatSI
#define myfloat_sub2_si    SubtractMyFloatSI
#define myfloat_mul2_si    MultiplyMyFloatSI
#define myfloat_div2_si    DivideMyFloatSI
#define myfloat_si_sub2    SubtractSIMyFloat
#define myfloat_si_div2    DivideSIMyFloat

#define myfloat_neg        NegateMyFloatA

/* built-in functions */
#define myfloat_set_sqrt   sqrtMyFloatA
#define myfloat_set_pow    ExponentiateMyFloatA
#define myfloat_set_pow_si ExponentiateMyFloatIA

#define myfloat_set_sin    sinMyFloatA
#define myfloat_set_cos    cosMyFloatA
#define myfloat_set_tan    tanMyFloatA
#define myfloat_set_atan   atanMyFloatA
#define myfloat_set_exp    expMyFloatA
#define myfloat_set_log    logMyFloatA
#define myfloat_set_sinh   sinhMyFloatA
#define myfloat_set_cosh   coshMyFloatA
#define myfloat_set_tanh   tanhMyFloatA
#define myfloat_set_log10  log10MyFloatA
#define myfloat_set_fabs   fabsMyFloatA
#define myfloat_to_si      MyFloatToInt
#define myfloat_to_d       MyFloatToDouble

/* boolean operations */
#define myfloat_ge  MyFloatA_GE_B
#define myfloat_gt  MyFloatA_GT_B
#define myfloat_le  MyFloatA_LE_B
#define myfloat_lt  MyFloatA_LT_B
#define myfloat_eq  MyFloatA_EQ_B
#define myfloat_neq MyFloatA_NEQ_B

/* output format */
#define myfloat_fprintf OutputMyFloat3

/* input format */
#define myfloat_fscanf InputMyFloat3
#endif /* END myfloat_t */


/* BEGIN PRECODE mycoef_myfloat_t_taylor */
#define mycoef_myfloat_t_taylor          MY_COEF
/* END PRECODE mycoef_myfloat_t_taylor */


/* BEGIN MY_COEF_MY_FLOAT_BASIC mycoef_myfloat_t_taylor */
#define mycoef_myfloat_initup2_taylor(s,d)    
#define mycoef_myfloat_initup_taylor()        
#define mycoef_myfloat_init_taylor            InitMyFloat
#define mycoef_myfloat_clean_taylor           ClearMyFloat
#define mycoef_myfloat_cleanup_taylor()       

/* assign */
#define mycoef_myfloat_set_taylor             AssignMyFloat
#define mycoef_myfloat_set_myfloat_taylor     AssignMyFloat
#define mycoef_myfloat_set_d_taylor           MakeMyFloatB
#define mycoef_myfloat_set_si_taylor          MakeMyFloatB
#define mycoef_myfloat_set_zero_taylor(r)     MakeMyFloatC(r,"0",0)

/* elemental operations */
#define mycoef_myfloat_add2_taylor            AddMyFloatA
#define mycoef_myfloat_sub2_taylor            SubtractMyFloatA
#define mycoef_myfloat_mul2_taylor            MultiplyMyFloatA
#define mycoef_myfloat_div2_taylor            DivideMyFloatA

#define mycoef_myfloat_add2_myfloat_taylor    AddMyFloatA
#define mycoef_myfloat_sub2_myfloat_taylor    SubtractMyFloatA
#define mycoef_myfloat_mul2_myfloat_taylor    MultiplyMyFloatA
#define mycoef_myfloat_div2_myfloat_taylor    DivideMyFloatA
#define mycoef_myfloat_myfloat_sub2_taylor    SubtractMyFloatA
#define mycoef_myfloat_myfloat_div2_taylor    DivideMyFloatA

#define mycoef_myfloat_add2_d_taylor          AddMyFloatD
#define mycoef_myfloat_sub2_d_taylor          SubtractMyFloatD
#define mycoef_myfloat_mul2_d_taylor          MultiplyMyFloatD
#define mycoef_myfloat_div2_d_taylor          DivideMyFloatD
#define mycoef_myfloat_d_sub2_taylor          SubtractDMyFloat
#define mycoef_myfloat_d_div2_taylor          DivideDMyFloat

#define mycoef_myfloat_add2_si_taylor         AddMyFloatSI
#define mycoef_myfloat_sub2_si_taylor         SubtractMyFloatSI
#define mycoef_myfloat_mul2_si_taylor         MultiplyMyFloatSI
#define mycoef_myfloat_div2_si_taylor         DivideMyFloatSI
#define mycoef_myfloat_si_sub2_taylor         SubtractSIMyFloat
#define mycoef_myfloat_si_div2_taylor         DivideSIMyFloat

#define mycoef_myfloat_neg_taylor             NegateMyFloatA

/* built-in functions */
#define mycoef_myfloat_set_sqrt_taylor        sqrtMyFloatA
#define mycoef_myfloat_set_pow_myfloat_taylor ExponentiateMyFloatA
#define mycoef_myfloat_set_pow_si_taylor      ExponentiateMyFloatIA

#define mycoef_myfloat_set_sin_taylor         sinMyFloatA
#define mycoef_myfloat_set_cos_taylor         cosMyFloatA
#define mycoef_myfloat_set_tan_taylor         tanMyFloatA
#define mycoef_myfloat_set_atan_taylor        atanMyFloatA
#define mycoef_myfloat_set_exp_taylor         expMyFloatA
#define mycoef_myfloat_set_log_taylor         logMyFloatA
#define mycoef_myfloat_set_sinh_taylor        sinhMyFloatA
#define mycoef_myfloat_set_cosh_taylor        coshMyFloatA
#define mycoef_myfloat_set_tanh_taylor        tanhMyFloatA
#define mycoef_myfloat_set_log10_taylor       log10MyFloatA
#define mycoef_myfloat_set_fabs_taylor        fabsMyFloatA

/* castings */
#define mycoef_myfloat_to_myfloat_taylor(a)   &(a)
#define mycoef_myfloat_to_si_taylor           MyFloatToInt
#define mycoef_myfloat_to_d_taylor            MyFloatToDouble

/* boolean operations */
#define mycoef_myfloat_ge_taylor  MyFloatA_GE_B
#define mycoef_myfloat_gt_taylor  MyFloatA_GT_B
#define mycoef_myfloat_le_taylor  MyFloatA_LE_B
#define mycoef_myfloat_lt_taylor  MyFloatA_LT_B
#define mycoef_myfloat_eq_taylor  MyFloatA_EQ_B
#define mycoef_myfloat_neq_taylor MyFloatA_NEQ_B

/* norms */
#define mycoef_myfloat_nrminf_taylor(a,b) mycoef_myfloat_set_fabs_taylor(*(a),b)
#define mycoef_myfloat_nrm2_taylor(a,b) mycoef_myfloat_mul2_taylor(*(a),b,b)

/* output format */
#define mycoef_myfloat_fprintf_taylor OutputMyFloat3

/* input format */
#define mycoef_myfloat_fscanf_taylor InputMyFloat3

/* string scanf */
#define mycoef_myfloat_sscanf4_taylor StringToMyFloat4
/* END MY_COEF_MY_FLOAT_BASIC mycoef_myfloat_t_taylor */


/* BEGIN MY_COEF_MY_FLOAT_BASIC mycoef_myfloat_t_taylor */
#define mycoef_myfloat_initup2_taylor(s,d)    
#define mycoef_myfloat_initup_taylor()        
#define mycoef_myfloat_init_taylor            InitMyFloat
#define mycoef_myfloat_clean_taylor           ClearMyFloat
#define mycoef_myfloat_cleanup_taylor()       

/* assign */
#define mycoef_myfloat_set_taylor             AssignMyFloat
#define mycoef_myfloat_set_myfloat_taylor     AssignMyFloat
#define mycoef_myfloat_set_d_taylor           MakeMyFloatB
#define mycoef_myfloat_set_si_taylor          MakeMyFloatB
#define mycoef_myfloat_set_zero_taylor(r)     MakeMyFloatC(r,"0",0)

/* elemental operations */
#define mycoef_myfloat_add2_taylor            AddMyFloatA
#define mycoef_myfloat_sub2_taylor            SubtractMyFloatA
#define mycoef_myfloat_mul2_taylor            MultiplyMyFloatA
#define mycoef_myfloat_div2_taylor            DivideMyFloatA

#define mycoef_myfloat_add2_myfloat_taylor    AddMyFloatA
#define mycoef_myfloat_sub2_myfloat_taylor    SubtractMyFloatA
#define mycoef_myfloat_mul2_myfloat_taylor    MultiplyMyFloatA
#define mycoef_myfloat_div2_myfloat_taylor    DivideMyFloatA
#define mycoef_myfloat_myfloat_sub2_taylor    SubtractMyFloatA
#define mycoef_myfloat_myfloat_div2_taylor    DivideMyFloatA

#define mycoef_myfloat_add2_d_taylor          AddMyFloatD
#define mycoef_myfloat_sub2_d_taylor          SubtractMyFloatD
#define mycoef_myfloat_mul2_d_taylor          MultiplyMyFloatD
#define mycoef_myfloat_div2_d_taylor          DivideMyFloatD
#define mycoef_myfloat_d_sub2_taylor          SubtractDMyFloat
#define mycoef_myfloat_d_div2_taylor          DivideDMyFloat

#define mycoef_myfloat_add2_si_taylor         AddMyFloatSI
#define mycoef_myfloat_sub2_si_taylor         SubtractMyFloatSI
#define mycoef_myfloat_mul2_si_taylor         MultiplyMyFloatSI
#define mycoef_myfloat_div2_si_taylor         DivideMyFloatSI
#define mycoef_myfloat_si_sub2_taylor         SubtractSIMyFloat
#define mycoef_myfloat_si_div2_taylor         DivideSIMyFloat

#define mycoef_myfloat_neg_taylor             NegateMyFloatA

/* built-in functions */
#define mycoef_myfloat_set_sqrt_taylor        sqrtMyFloatA
#define mycoef_myfloat_set_pow_myfloat_taylor ExponentiateMyFloatA
#define mycoef_myfloat_set_pow_si_taylor      ExponentiateMyFloatIA

#define mycoef_myfloat_set_sin_taylor         sinMyFloatA
#define mycoef_myfloat_set_cos_taylor         cosMyFloatA
#define mycoef_myfloat_set_tan_taylor         tanMyFloatA
#define mycoef_myfloat_set_atan_taylor        atanMyFloatA
#define mycoef_myfloat_set_exp_taylor         expMyFloatA
#define mycoef_myfloat_set_log_taylor         logMyFloatA
#define mycoef_myfloat_set_sinh_taylor        sinhMyFloatA
#define mycoef_myfloat_set_cosh_taylor        coshMyFloatA
#define mycoef_myfloat_set_tanh_taylor        tanhMyFloatA
#define mycoef_myfloat_set_log10_taylor       log10MyFloatA
#define mycoef_myfloat_set_fabs_taylor        fabsMyFloatA

/* castings */
#define mycoef_myfloat_to_myfloat_taylor(a)   &(a)
#define mycoef_myfloat_to_si_taylor           MyFloatToInt
#define mycoef_myfloat_to_d_taylor            MyFloatToDouble

/* boolean operations */
#define mycoef_myfloat_ge_taylor  MyFloatA_GE_B
#define mycoef_myfloat_gt_taylor  MyFloatA_GT_B
#define mycoef_myfloat_le_taylor  MyFloatA_LE_B
#define mycoef_myfloat_lt_taylor  MyFloatA_LT_B
#define mycoef_myfloat_eq_taylor  MyFloatA_EQ_B
#define mycoef_myfloat_neq_taylor MyFloatA_NEQ_B

/* norms */
#define mycoef_myfloat_nrminf_taylor(a,b) mycoef_myfloat_set_fabs_taylor(*(a),b)
#define mycoef_myfloat_nrm2_taylor(a,b) mycoef_myfloat_mul2_taylor(*(a),b,b)

/* output format */
#define mycoef_myfloat_fprintf_taylor OutputMyFloat3

/* input format */
#define mycoef_myfloat_fscanf_taylor InputMyFloat3

/* string scanf */
#define mycoef_myfloat_sscanf4_taylor StringToMyFloat4
/* END MY_COEF_MY_FLOAT_BASIC mycoef_myfloat_t_taylor */


/* BEGIN MY_COEF_MY_FLOAT_POSTCODE mycoef_myfloat_t_taylor */
/* MACROS TO LINK MY_COEF */
#ifndef mycoef_t 
#define mycoef_t mycoef_myfloat_t_taylor

#define mycoef_initup() mycoef_myfloat_initup2_taylor(_MY_COEF_MAX_NUM_SYMBOLS_,_MY_COEF_MAX_DEGREE_)
#define mycoef_init(a)  mycoef_myfloat_init_taylor((a))
#define mycoef_clean(a) mycoef_myfloat_clean_taylor((a))
#define mycoef_cleanup  mycoef_myfloat_cleanup_taylor

/* norm functions */
#define mycoef_nrminf mycoef_myfloat_nrminf_taylor
#define mycoef_nrm2 mycoef_myfloat_nrm2_taylor

/* casts */
#define mycoef_to_myfloat mycoef_myfloat_to_myfloat_taylor

/* assign */
#define mycoef_set mycoef_myfloat_set_taylor
#define mycoef_set_zero mycoef_myfloat_set_zero_taylor
#define mycoef_set_myfloat mycoef_myfloat_set_myfloat_taylor
#define mycoef_set_d mycoef_myfloat_set_d_taylor
#define mycoef_set_si mycoef_myfloat_set_si_taylor

/* elemental operations */
#define mycoef_add2 mycoef_myfloat_add2_taylor
#define mycoef_sub2 mycoef_myfloat_sub2_taylor
#define mycoef_mul2 mycoef_myfloat_mul2_taylor
#define mycoef_div2 mycoef_myfloat_div2_taylor

#define mycoef_add2_myfloat mycoef_myfloat_add2_myfloat_taylor
#define mycoef_sub2_myfloat mycoef_myfloat_sub2_myfloat_taylor
#define mycoef_myfloat_sub2 mycoef_myfloat_myfloat_sub2_taylor
#define mycoef_mul2_myfloat mycoef_myfloat_mul2_myfloat_taylor
#define mycoef_div2_myfloat mycoef_myfloat_div2_myfloat_taylor
#define mycoef_myfloat_div2 mycoef_myfloat_myfloat_div2_taylor

#define mycoef_add2_d mycoef_myfloat_add2_d_taylor
#define mycoef_sub2_d mycoef_myfloat_sub2_d_taylor
#define mycoef_mul2_d mycoef_myfloat_mul2_d_taylor
#define mycoef_div2_d mycoef_myfloat_div2_d_taylor
#define mycoef_d_sub2 mycoef_myfloat_d_sub2_taylor
#define mycoef_d_div2 mycoef_myfloat_d_div2_taylor

#define mycoef_add2_si mycoef_myfloat_add2_si_taylor
#define mycoef_sub2_si mycoef_myfloat_sub2_si_taylor
#define mycoef_mul2_si mycoef_myfloat_mul2_si_taylor
#define mycoef_div2_si mycoef_myfloat_div2_si_taylor
#define mycoef_si_sub2 mycoef_myfloat_si_sub2_taylor
#define mycoef_si_div2 mycoef_myfloat_si_div2_taylor

#define mycoef_neg mycoef_myfloat_neg_taylor

/* built-in functions */
#define mycoef_set_sqrt mycoef_myfloat_set_sqrt_taylor
#define mycoef_set_pow_myfloat mycoef_myfloat_set_pow_myfloat_taylor
#define mycoef_set_pow_si mycoef_myfloat_set_pow_si_taylor

#define mycoef_set_sin mycoef_myfloat_set_sin_taylor
#define mycoef_set_cos mycoef_myfloat_set_cos_taylor
#define mycoef_set_tan mycoef_myfloat_set_tan_taylor
#define mycoef_set_atan mycoef_myfloat_set_atan_taylor
#define mycoef_set_exp mycoef_myfloat_set_exp_taylor
#define mycoef_set_log mycoef_myfloat_set_log_taylor
#define mycoef_set_sinh mycoef_myfloat_set_sinh_taylor
#define mycoef_set_cosh mycoef_myfloat_set_cosh_taylor
#define mycoef_set_tanh mycoef_myfloat_set_tanh_taylor
#define mycoef_set_log10 mycoef_myfloat_set_log10_taylor
#define mycoef_set_fabs mycoef_myfloat_set_fabs_taylor

/* castings */
#define mycoef_to_si mycoef_myfloat_to_si_taylor
#define mycoef_to_d mycoef_myfloat_to_d_taylor

/* boolean operations */
#define mycoef_ge mycoef_myfloat_ge_taylor
#define mycoef_gt mycoef_myfloat_gt_taylor
#define mycoef_le mycoef_myfloat_le_taylor
#define mycoef_lt mycoef_myfloat_lt_taylor
#define mycoef_eq mycoef_myfloat_eq_taylor
#define mycoef_neq mycoef_myfloat_neq_taylor

/* output format */
#define mycoef_fprintf mycoef_myfloat_fprintf_taylor

/* input format */
#define mycoef_fscanf mycoef_myfloat_fscanf_taylor

/* string scanf */
#define mycoef_sscanf4 mycoef_myfloat_sscanf4_taylor
#endif /* END my_coef_t */

 
/* END MY_COEF_MY_FLOAT_POSTCODE mycoef_myfloat_t_taylor */

/* CODE jet_tree_t_taylor */
int * jet_tree_monomial_counts_taylor(void) {return _jet_tree_monomial_counts_taylor_;}
int * jet_tree_monomial_offsets_taylor(void) {return _jet_tree_monomial_offsets_taylor_;}

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>


static myfloat_t jet_tree_faux_taylor;
static mycoef_t jet_tree_caux_taylor;
static jet_tree_t_taylor jet_tree_jaux_taylor=NULL;
#pragma omp threadprivate(jet_tree_faux_taylor,jet_tree_caux_taylor,jet_tree_jaux_taylor)

/* for advanced special functions */
static int jet_tree_ipool_taylor=0;
static jet_tree_t_taylor *jet_tree_pool_taylor=NULL;
#pragma omp threadprivate(jet_tree_ipool_taylor,jet_tree_pool_taylor)

static int jet_tree_flag_init_jet_library_taylor=0;
static int jet_tree_nsymb_taylor=_NUMBER_OF_MAX_SYMBOLS_,jet_tree_deg_taylor=_MAX_DEGREE_OF_JET_VARS_;
#pragma omp threadprivate(jet_tree_flag_init_jet_library_taylor,jet_tree_nsymb_taylor,jet_tree_deg_taylor)

#define mycoef_axpy(y,a,x) {\
  mycoef_mul2(jet_tree_caux_taylor,a,x);\
  mycoef_add2(y,y,jet_tree_caux_taylor);}
#define mycoef_sixpy(y,a,x) {\
  mycoef_mul2_si(jet_tree_caux_taylor,x,a);\
  mycoef_add2(y,y,jet_tree_caux_taylor);}

#define mycoef_axpy_coef(y,s,a,x) {\
  mycoef_mul2(jet_tree_caux_taylor,a,x);\
  mycoef_mul2(jet_tree_caux_taylor,jet_tree_caux_taylor,s);\
  mycoef_add2(y,y,jet_tree_caux_taylor);}
#define mycoef_axpy_myfloat(y,s,a,x) {\
  mycoef_mul2(jet_tree_caux_taylor,a,x);\
  mycoef_mul2_myfloat(jet_tree_caux_taylor,jet_tree_caux_taylor,s);\
  mycoef_add2(y,y,jet_tree_caux_taylor);}
#define mycoef_axpy_si(y,s,a,x) {\
  mycoef_mul2(jet_tree_caux_taylor,a,x);\
  mycoef_mul2_si(jet_tree_caux_taylor,jet_tree_caux_taylor,s);\
  mycoef_add2(y,y,jet_tree_caux_taylor);}


#define mycoef_axmy(y,a,x) {\
  mycoef_mul2(jet_tree_caux_taylor,a,x);\
  mycoef_sub2(y,y,jet_tree_caux_taylor);}
#define mycoef_sixmy(y,a,x) {\
  mycoef_mul2_si(jet_tree_caux_taylor,x,a);\
  mycoef_sub2(y,y,jet_tree_caux_taylor);}

#define mycoef_axmy_coef(y,s,a,x) {\
  mycoef_mul2(jet_tree_caux_taylor,a,x);\
  mycoef_mul2(jet_tree_caux_taylor,jet_tree_caux_taylor,s);\
  mycoef_sub2(y,y,jet_tree_caux_taylor);}
#define mycoef_axmy_si(y,s,a,x) {\
  mycoef_mul2(jet_tree_caux_taylor,a,x);\
  mycoef_mul2_si(jet_tree_caux_taylor,jet_tree_caux_taylor,s);\
  mycoef_sub2(y,y,jet_tree_caux_taylor);}

#define jet_tree_nch_taylor_node(n,k) jet_tree_num_coefs_homogeneous_taylor[(n)*(_MAX_DEGREE_OF_JET_VARS_+1)+(k)]


size_t jet_tree_create_tree_taylor_node(jet_tree_ptr_taylor_node h, mycoef_t *coef) {
  static mycoef_t *pcoef=NULL;
#pragma omp threadprivate(pcoef)
  int n, k, m;
  size_t mem=0;
  
  if (coef) pcoef = coef;
  n = h->nsymb;
  k = h->deg;
  h->coef = pcoef;
  
  if (n==1) { ++pcoef; h->term=NULL; }
  else if (k == 0) { ++pcoef; h->term=NULL; }
  else {
    mem=(k+1)*sizeof(*h->term);
    h->term = (__typeof__(h->term)) malloc(mem);
    if (h->term==NULL) {
      fprintf(stderr,"%s:%d not enough memory to allocate\n",__FILE__,__LINE__);
      fflush(stderr); exit(2);
    }
    
    for (m = 0; m <= k; ++m) {
      (h->term[m]).nsymb = n-1;
      (h->term[m]).deg = k-m;
      mem+= jet_tree_create_tree_taylor_node(h->term + m, NULL);
    }
  }
  return mem;
}

size_t jet_tree_init_taylor_node(jet_tree_ptr_taylor_node h, int nsymb, int deg, mycoef_t *coef)
{
  // assert(h);
  h->nsymb = nsymb;
  h->deg = deg;
  h->coef = coef;
  h->term = NULL;
  return jet_tree_create_tree_taylor_node(h,coef);
  size_t mem = 0;
  if (nsymb > 2 && deg > 0)
    {
      __typeof__(h->deg) i;

      mem = (deg + 1) * sizeof(*h->term);
      h->term = (__typeof__(h->term)) malloc(mem); // assert(h->term);
      --nsymb;
//      for (i = 0; i <= deg; ++i)
      for (i = deg; i > 0; --i)
        {
          mem  += jet_tree_init_taylor_node(h->term + (deg-i), nsymb, i, coef);
          coef += jet_tree_nch_taylor_node(nsymb, i);
        }
      mem += jet_tree_init_taylor_node(h->term + deg, nsymb, i, coef);
    }
  return mem;
}

void jet_tree_clean_taylor_node(jet_tree_ptr_taylor_node h)
{
  if (h->term==NULL) return;

  __typeof__(h->term) ht, hf;
  for (ht = h->term, hf = ht + h->deg;
       ht < hf;
       jet_tree_clean_taylor_node(ht), ++ht){}
  jet_tree_clean_taylor_node(ht);

  free(h->term); h->term = NULL;
}

void jet_tree_set_taylor_node(jet_tree_ptr_taylor_node h, jet_tree_ptr_taylor_node a)
{
  // assert(h && a); // assert(h->nsymb == a->nsymb); // assert(h->deg == h->deg);
  if (h == a || h->coef == a->coef) return;

  __typeof__(h->coef) hc, ac, hf;
  for (hc = h->coef, hf = hc + jet_tree_nch_taylor_node(h->nsymb, h->deg), ac = a->coef;
       hc < hf;
       ++hc, ++ac){mycoef_set((*hc),(*ac));}
}

void jet_tree_set_coef_taylor_node(jet_tree_ptr_taylor_node h, mycoef_t coef)
{
  __typeof__(h->coef) hc, hf;
  for (hc = h->coef, hf = hc + jet_tree_nch_taylor_node(h->nsymb, h->deg);
       hc < hf;
       ++hc){mycoef_set((*hc),coef);}
}

void jet_tree_set_myfloat_taylor_node(jet_tree_ptr_taylor_node h, myfloat_t myf)
{
  __typeof__(h->coef) hc, hf;
  for (hc = h->coef, hf = hc + jet_tree_nch_taylor_node(h->nsymb, h->deg);
       hc < hf;
       ++hc){mycoef_set_myfloat((*hc),myf);}
}

void jet_tree_set_si_taylor_node(jet_tree_ptr_taylor_node h, int d)
{
  __typeof__(h->coef) hc, hf;
  for (hc = h->coef, hf = hc + jet_tree_nch_taylor_node(h->nsymb, h->deg);
       hc < hf;
       ++hc){mycoef_set_si((*hc),d);}
}

void jet_tree_set_d_taylor_node(jet_tree_ptr_taylor_node h, double d)
{
  __typeof__(h->coef) hc, hf;
  for (hc = h->coef, hf = hc + jet_tree_nch_taylor_node(h->nsymb, h->deg);
       hc < hf;
       ++hc){mycoef_set_d((*hc),d);}
}

#define jet_tree_set_zero_taylor_node(h,hc,hf)\
{\
  for (hc = (h).coef, hf = hc + jet_tree_nch_taylor_node((h).nsymb, (h).deg);\
       hc < hf;\
       ++hc){mycoef_set_zero(*hc);}\
}\

void jet_tree_nrminf_taylor_node(myfloat_t nrm[1], jet_tree_ptr_taylor_node h)
{
  __typeof__(h->coef) hc, hf;
  for (hc = h->coef, hf = hc + jet_tree_nch_taylor_node(h->nsymb, h->deg);
       hc < hf;
       ++hc)
   {
      mycoef_nrminf(&jet_tree_faux_taylor,(*hc));
      if (myfloat_lt(*nrm,jet_tree_faux_taylor))
      {myfloat_set(*nrm,jet_tree_faux_taylor);}
   }
}

void jet_tree_nrm2_taylor_node(myfloat_t nrm[1], jet_tree_ptr_taylor_node h)
{
  __typeof__(h->coef) hc, hf;
  for (hc = h->coef, hf = hc + jet_tree_nch_taylor_node(h->nsymb, h->deg);
       hc < hf;
       ++hc)
   {
      mycoef_nrm2(&jet_tree_faux_taylor,(*hc));
      myfloat_add2(*nrm,*nrm,jet_tree_faux_taylor);
   }
}

static void jet_tree_neg_taylor_node(jet_tree_ptr_taylor_node h, jet_tree_ptr_taylor_node a)
{
  // assert(h && a); // assert(h->nsymb == a->nsymb); // assert(h->deg == h->deg);
  // assert(h->term && a->term);
//  if (h == a || h->term == a->term) return;

  __typeof__(h->coef) hc, ac, hf;
  for (hc = h->coef, hf = hc + jet_tree_nch_taylor_node(h->nsymb, h->deg), ac = a->coef;
       hc < hf;
       ++hc, ++ac){mycoef_neg(*hc,*ac);}
}

/* y <- y - a*x */
#define jet_tree_axmy_taylor_node(y,a,x,yc,yf,xc) {\
  for (yc = y->coef, yf = y->coef + jet_tree_nch_taylor_node(y->nsymb,y->deg), xc = x->coef;\
       yc < yf;\
       ++yc, ++xc){mycoef_axmy((*yc),a,(*xc));}\
}

/* y <- y + a*x */
#define jet_tree_axpy_taylor_node(y,a,x,yc,yf,xc) {\
  for (yc = y->coef, yf = y->coef + jet_tree_nch_taylor_node(y->nsymb,y->deg), xc = x->coef;\
       yc < yf;\
       ++yc, ++xc){mycoef_axpy((*yc),a,(*xc));}\
}

/* y <- y + s*a*x */
#define jet_tree_axpy_coef_taylor_node(y,s,a,x,yc,yf,xc) {\
  for (yc = y->coef, yf = y->coef + jet_tree_nch_taylor_node(y->nsymb,y->deg), xc = x->coef;\
       yc < yf;\
       ++yc, ++xc){mycoef_axpy_coef((*yc),s,a,(*xc));}\
}
/* y <- y + s*a*x */
#define jet_tree_axpy_myfloat_taylor_node(y,s,a,x,yc,yf,xc) {\
  for (yc = y->coef, yf = y->coef + jet_tree_nch_taylor_node(y->nsymb,y->deg), xc = x->coef;\
       yc < yf;\
       ++yc, ++xc){mycoef_axpy_myfloat((*yc),s,a,(*xc));}\
}
#define jet_tree_axpy_d_taylor_node(y,s,a,x,yc,yf,xc) {\
  for (yc = y->coef, yf = y->coef + jet_tree_nch_taylor_node(y->nsymb,y->deg), xc = x->coef;\
       yc < yf;\
       ++yc, ++xc){mycoef_axpy_d((*yc),s,a,(*xc));}\
}
#define jet_tree_axpy_si_taylor_node(y,s,a,x,yc,yf,xc) {\
  for (yc = y->coef, yf = y->coef + jet_tree_nch_taylor_node(y->nsymb,y->deg), xc = x->coef;\
       yc < yf;\
       ++yc, ++xc){mycoef_axpy_si((*yc),s,a,(*xc));}\
}

/* h <- a + b */
void jet_tree_add2_taylor_node(jet_tree_ptr_taylor_node h, jet_tree_ptr_taylor_node a, jet_tree_ptr_taylor_node b)
{
  // assert(h && a && b);
  // assert(h->nsymb == a->nsymb && p->nsymb == b->nsymb);
  // assert(h->deg == a->deg && h->deg == b->deg);
  int i, k = jet_tree_nch_taylor_node(h->nsymb, h->deg);
  for (i = 0; i < k; ++i)
  {mycoef_add2(h->coef[i],a->coef[i],b->coef[i]);}
}

/* h <- a - b */
static void jet_tree_sub2_taylor_node(jet_tree_ptr_taylor_node h, jet_tree_ptr_taylor_node a, jet_tree_ptr_taylor_node b)
{
  // assert(h && a && b); // assert(h != b);
  // assert(h->nsymb == a->nsymb && h->nsymb == b->nsymb);
  // assert(h->deg == a->deg && h->deg == b->deg);
  int i, k = jet_tree_nch_taylor_node(h->nsymb, h->deg);
  for (i = 0; i < k; ++i)
  {mycoef_sub2(h->coef[i],a->coef[i],b->coef[i]);}
}

/* h <- h + a*b */
void jet_tree_pph_taylor_node(jet_tree_ptr_taylor_node h, jet_tree_ptr_taylor_node a, jet_tree_ptr_taylor_node b)
{
  // assert(h && a && b); //// assert(h != a && h != b);
  if (h->nsymb > 2)
    {
      __typeof__(h->coef) hc, hf, ac;
      if (a->deg > 0)
        {
          if (b->deg > 0)
            {
              __typeof__(*h) *aa, *bb, *hh, *hh0, *af, *bf;
              af = a->term + a->deg; bf = b->term + b->deg;
              for (aa = a->term, hh0 = h->term; aa < af; ++aa, ++hh0)
                {
                  for (bb = b->term, hh = hh0;
                       bb < bf;
                       jet_tree_pph_taylor_node(hh, aa, bb), ++bb, ++hh){}
//                  // assert(pp <= p->term + p->deg);
                  jet_tree_axpy_taylor_node(hh,*(bb->coef),aa, hc,hf,ac);
                }
//              // assert(pp0 <= p->term + p->deg);
              for (bb = b->term, hh = hh0;
                   bb < bf;
                   ++bb, ++hh){jet_tree_axpy_taylor_node(hh,*(aa->coef),bb, hc,hf,ac);}
              mycoef_axpy(*(hh->coef),*(aa->coef),*(bb->coef));
            }
          else jet_tree_axpy_taylor_node(h,*(b->coef),a, hc,hf,ac);
        }
      else jet_tree_axpy_taylor_node(h,*(a->coef),b, hc,hf,ac);
    }
  else if (h->nsymb == 2)
    {
      __typeof__(*h->coef) *aa, *bb, *hh, *hh0, *af, *bf;
      af = a->coef + a->deg; bf = b->coef + b->deg;
      for (aa = a->coef, hh0 = h->coef; aa <= af; ++aa, ++hh0)
        for (bb = b->coef, hh = hh0;
             bb <= bf;
             ++bb, ++hh){mycoef_axpy((*hh),(*aa),(*bb));}
    }
  else mycoef_axpy(*(h->coef), *(a->coef), *(b->coef));
}

/* h <- h - a*b */
void jet_tree_mph_taylor_node(jet_tree_ptr_taylor_node h, jet_tree_ptr_taylor_node a, jet_tree_ptr_taylor_node b)
{
  // assert(h && a && b); //// assert(h != a && h != b);
  if (h->nsymb > 2)
    {
      __typeof__(h->coef) hc, hf, ac;
      if (a->deg > 0)
        {
          if (b->deg > 0)
            {
              __typeof__(*h) *aa, *bb, *hh, *hh0, *af, *bf;
              af = a->term + a->deg; bf = b->term + b->deg;
              for (aa = a->term, hh0 = h->term; aa < af; ++aa, ++hh0)
                {
                  for (bb = b->term, hh = hh0;
                       bb < bf;
                       jet_tree_mph_taylor_node(hh, aa, bb), ++bb, ++hh){}
//                  // assert(pp <= p->term + p->deg);
                  jet_tree_axmy_taylor_node(hh,*(bb->coef),aa, hc,hf,ac);
                }
//              // assert(pp0 <= p->term + p->deg);
              for (bb = b->term, hh = hh0;
                   bb < bf;
                   ++bb, ++hh){jet_tree_axmy_taylor_node(hh,*(aa->coef),bb, hc,hf,ac);}
              mycoef_axmy(*(hh->coef),*(aa->coef),*(bb->coef));
            }
          else jet_tree_axmy_taylor_node(h,*(b->coef),a, hc,hf,ac);
        }
      else jet_tree_axmy_taylor_node(h,*(a->coef), b, hc,hf,ac);
    }
  else if (h->nsymb == 2)
    {
      __typeof__(*h->coef) *aa, *bb, *hh, *hh0, *af, *bf;
      af = a->coef + a->deg; bf = b->coef + b->deg;
      for (aa = a->coef, hh0 = h->coef; aa <= af; ++aa, ++hh0)
        for (bb = b->coef, hh = hh0;
             bb <= bf;
             ++bb, ++hh) {mycoef_axmy((*hh), (*aa), (*bb));}
    }
  else mycoef_axmy(*(h->coef),*(a->coef),*(b->coef));
}

/* h <- h + s*a*b */
void jet_tree_pph_myfloat_taylor_node(jet_tree_ptr_taylor_node h, myfloat_t myf, jet_tree_ptr_taylor_node a, jet_tree_ptr_taylor_node b)
{
  if (h->nsymb > 2)
    {
      __typeof__(h->coef) hc, hf, ac;
      if (a->deg > 0)
        {
          if (b->deg > 0)
            {
              __typeof__(*h) *aa, *bb, *hh, *hh0, *af, *bf;
              af = a->term + a->deg; bf = b->term + b->deg;
              for (aa = a->term, hh0 = h->term; aa < af; ++aa, ++hh0)
                {
                  for (bb = b->term, hh = hh0;
                       bb < bf;
                       jet_tree_pph_myfloat_taylor_node(hh, myf, aa, bb), ++bb, ++hh){}
//                  // assert(pp <= p->term + p->deg);
                  jet_tree_axpy_myfloat_taylor_node(hh,myf,*(bb->coef),aa, hc, hf, ac);
                }
//              // assert(pp0 <= p->term + p->deg);
              for (bb = b->term, hh = hh0;
                   bb < bf;
                   ++bb, ++hh){jet_tree_axpy_myfloat_taylor_node(hh,myf,*(aa->coef),bb, hc, hf, ac);}
              mycoef_axpy_myfloat(*(hh->coef),myf,*(aa->coef),*(bb->coef));
            }
          else jet_tree_axpy_myfloat_taylor_node(h,myf,*(b->coef),a, hc, hf, ac);
        }
      else {jet_tree_axpy_myfloat_taylor_node(h,myf,*(a->coef),b, hc, hf, ac);}
    }
  else if (h->nsymb == 2)
    {
      __typeof__(*h->coef) *aa, *bb, *hh, *hh0, *af, *bf;
      af = a->coef + a->deg; bf = b->coef + b->deg;
      for (aa = a->coef, hh0 = h->coef; aa <= af; ++aa, ++hh0)
        for (bb = b->coef, hh = hh0;
             bb <= bf;
             ++bb, ++hh){mycoef_axpy_myfloat((*hh), myf, (*aa), (*bb));}
    }
  else {mycoef_axpy_myfloat(*(h->coef),myf,*(a->coef),*(b->coef));}
}

void jet_tree_pph_si_taylor_node(jet_tree_ptr_taylor_node h, int coef, jet_tree_ptr_taylor_node a, jet_tree_ptr_taylor_node b)
{
  // assert(h && a && b); //// assert(h != a && h != b);
  if (h->nsymb > 2)
    {
      __typeof__(h->coef) hc, hf, ac;
      if (a->deg > 0)
        {
          if (b->deg > 0)
            {
              __typeof__(*h) *aa, *bb, *hh, *hh0, *af, *bf;
              af = a->term + a->deg; bf = b->term + b->deg;
              for (aa = a->term, hh0 = h->term; aa < af; ++aa, ++hh0)
                {
                  for (bb = b->term, hh = hh0;
                       bb < bf;
                       jet_tree_pph_si_taylor_node(hh, coef, aa, bb), ++bb, ++hh){}
//                  // assert(pp <= p->term + p->deg);
                  jet_tree_axpy_si_taylor_node(hh,coef,*(bb->coef),aa, hc, hf, ac);
                }
//              // assert(pp0 <= p->term + p->deg);
              for (bb = b->term, hh = hh0;
                   bb < bf;
                   ++bb, ++hh){jet_tree_axpy_si_taylor_node(hh,coef,*(aa->coef),bb, hc, hf, ac);}
              mycoef_axpy_si(*(hh->coef),coef,*(aa->coef),*(bb->coef));
            }
          else jet_tree_axpy_si_taylor_node(h,coef,*(b->coef),a, hc, hf, ac);
        }
      else {jet_tree_axpy_si_taylor_node(h,coef,*(a->coef),b, hc, hf, ac);}
    }
  else if (h->nsymb == 2)
    {
      __typeof__(*h->coef) *aa, *bb, *hh, *hh0, *af, *bf;
      af = a->coef + a->deg; bf = b->coef + b->deg;
      for (aa = a->coef, hh0 = h->coef; aa <= af; ++aa, ++hh0)
        for (bb = b->coef, hh = hh0;
             bb <= bf;
             ++bb, ++hh){mycoef_axpy_si((*hh), coef, (*aa), (*bb));}
    }
  else {mycoef_axpy_si(*(h->coef),coef,*(a->coef),*(b->coef));}
}

#define jet_tree_mul2_coef_taylor_node(h,a,s, hc,hf,ac) {\
  for (hc = (h).coef, hf = hc + jet_tree_nch_taylor_node((h).nsymb, (h).deg), ac = (a).coef;\
       hc < hf;\
       ++hc, ++ac){mycoef_mul2((*hc),(*ac),s);}\
}
#define jet_tree_mul2_myfloat_taylor_node(h,a,s, hc,hf,ac) {\
  for (hc = (h).coef, hf = hc + jet_tree_nch_taylor_node((h).nsymb, (h).deg), ac = (a).coef;\
       hc < hf;\
       ++hc, ++ac){mycoef_mul2_myfloat((*hc),(*ac),s);}\
}
#define jet_tree_mul2_si_taylor_node(h,a,s, hc,hf,ac) {\
  for (hc = (h).coef, hf = hc + jet_tree_nch_taylor_node((h).nsymb, (h).deg), ac = (a).coef;\
       hc < hf;\
       ++hc, ++ac){mycoef_mul2_si((*hc),(*ac),s);}\
}
#define jet_tree_mul2_d_taylor_node(h,a,s, hc,hf,ac) {\
  for (hc = (h).coef, hf = hc + jet_tree_nch_taylor_node((h).nsymb, (h).deg), ac = (a).coef;\
       hc < hf;\
       ++hc, ++ac){mycoef_mul2_d((*hc),(*ac),s);}\
}

#define jet_tree_div2_coef_taylor_node(h,a,s, hc,hf,ac) {\
  for (hc = (h).coef, hf = hc + jet_tree_nch_taylor_node((h).nsymb, (h).deg), ac = (a).coef;\
       hc < hf;\
       ++hc, ++ac){mycoef_div2((*hc),(*ac),s);}\
}
#define jet_tree_div2_myfloat_taylor_node(h,a,s, hc,hf,ac) {\
  for (hc = (h).coef, hf = hc + jet_tree_nch_taylor_node((h).nsymb, (h).deg), ac = (a).coef;\
       hc < hf;\
       ++hc, ++ac){mycoef_div2_myfloat((*hc),(*ac),s);}\
}
#define jet_tree_div2_si_taylor_node(h,a,s, hc,hf,ac) {\
  for (hc = (h).coef, hf = hc + jet_tree_nch_taylor_node((h).nsymb, (h).deg), ac = (a).coef;\
       hc < hf;\
       ++hc, ++ac){mycoef_div2_si((*hc),(*ac),s);}\
}
#define jet_tree_div2_d_taylor_node(h,a,s, hc,hf,ac) {\
  for (hc = (h).coef, hf = hc + jet_tree_nch_taylor_node((h).nsymb, (h).deg), ac = (a).coef;\
       hc < hf;\
       ++hc, ++ac){mycoef_div2_d((*hc),(*ac),s);}\
}

#define jet_tree_get_zero_coef_taylor_node(x) (x)->coef

mycoef_t* jet_tree_get_coef_taylor_node(jet_tree_ptr_taylor_node h, const int idx[])
{
  int k;
  for (k = h->nsymb-1; k >= 0; --k)
    {
      if (h->nsymb==1 || h->deg==0) break;
      h = h->term+idx[k];
    }
  return h->coef;
}

void jet_tree_sumeval_taylor_node(mycoef_t val[1], jet_tree_ptr_taylor_node h, myfloat_t x[])
{
  int n, k, m;
  myfloat_t x1, xk;
  mycoef_t y;
  mycoef_init(y); mycoef_set_zero(y);
  myfloat_init(x1);
  myfloat_init(xk);
  n= h->nsymb;
  k= h->deg;
  myfloat_set(x1,x[n-1]);
  if (k== 0) {
    mycoef_add2(y,y,*(h->coef));
  } else if (n==1) {
    myfloat_set_si(xk,1);
    for (m = 0; m < k; ++m) {
      myfloat_mul2(xk,xk,x1);
    }
    mycoef_mul2_myfloat(y,*(h->coef),xk);
  } else {
    jet_tree_sumeval_taylor_node(&y,(h->term)+k, x);
    for (m= k; m>0; m--) {
      mycoef_mul2_myfloat(y,y,x1);
      jet_tree_sumeval_taylor_node(&y,h->term+m-1, x);
    }
  }
  mycoef_add2(*val,*val,y);
  mycoef_clean(y);
  myfloat_clean(x1);
  myfloat_clean(xk);
}

void jet_tree_fprintf_taylor_node(FILE *const file, const char *fmt, jet_tree_ptr_taylor_node h)
{
  // assert(h && h->coef);
  mycoef_t *hc, *hf;

  for (hc = h->coef, hf = hc + jet_tree_nch_taylor_node(h->nsymb, h->deg);
       hc < hf;
       mycoef_fprintf(file, fmt, *hc), ++hc){}
}



size_t jet_tree_init_taylor(jet_tree_ptr_taylor s)
{
  // assert(s);
  int i, j;
  mycoef_t *coef=NULL;
  size_t mem, k;

  k = (_MAX_DEGREE_OF_JET_VARS_ + 1) * sizeof(**s);
  *s = (__typeof__(*s)) malloc(k);
  if (*s==NULL) {
    fprintf(stderr,"%s:%d Not enough memory\n",__FILE__,__LINE__);
    fflush(stderr); exit(2);
   }
  mem = k;
  k = _JET_COEFFICIENTS_COUNT_TOTAL_;
  coef = (__typeof__(coef)) malloc(k * sizeof(*coef));
  if (coef==NULL) {
    fprintf(stderr,"%s:%d Not enough memory\n",__FILE__,__LINE__);
    fflush(stderr); exit(2);
   }
  for (j = 0; j < k; ++j) {mycoef_init(coef[j]);}
  mem+= k * sizeof(*coef);
  for (i = 0; i <= _MAX_DEGREE_OF_JET_VARS_; ++i)
    {
      /*k = jet_tree_nch_taylor_node(_NUMBER_OF_MAX_SYMBOLS_, i);
      coef = (__typeof__(coef)) malloc(k * sizeof(*coef));
      if (coef==NULL) {
        fprintf(stderr,"%s:%d Not enough memory\n",__FILE__,__LINE__);
        fflush(stderr); exit(2);
       }
      for (j = 0; j < k; ++j) {mycoef_init(coef[j]);}
      mem += k * sizeof(*coef);*/
      mem += jet_tree_init_taylor_node((*s) + i, _NUMBER_OF_MAX_SYMBOLS_, i, coef);
      coef+= jet_tree_nch_taylor_node(_NUMBER_OF_MAX_SYMBOLS_, i);
    }
  return mem;
}

void jet_tree_initup2_taylor(int ns, int dg)
{
  if (jet_tree_flag_init_jet_library_taylor==1) return;
#pragma omp single
{
  if (ns > _NUMBER_OF_MAX_SYMBOLS_) {
    fprintf(stderr, "%s:%d nsymb value illegal %d > %d\n", __FILE__,__LINE__, ns, _NUMBER_OF_MAX_SYMBOLS_);
    fflush(stderr); exit(1);
  }
  if (dg > _MAX_DEGREE_OF_JET_VARS_) {
    fprintf(stderr, "%s:%d deg value illegal %d > %d\n", __FILE__,__LINE__, dg, _MAX_DEGREE_OF_JET_VARS_);
    fflush(stderr); exit(1);
  }
}
  jet_tree_nsymb_taylor = ns;
  jet_tree_deg_taylor = dg;
  mycoef_initup();
  myfloat_init(jet_tree_faux_taylor);
  mycoef_init(jet_tree_caux_taylor);
  
  {
  int i;
  jet_tree_pool_taylor = (__typeof__(jet_tree_pool_taylor)) malloc((2*_NUMBER_OF_MAX_SYMBOLS_+1)*sizeof(*jet_tree_pool_taylor));
  if (jet_tree_pool_taylor==NULL)
    {
      fprintf(stderr,"%s:%d Not enough memory\n",__FILE__,__LINE__);
      fflush(stderr); exit(2);
    }
  for (i = 0; i <= 2*_NUMBER_OF_MAX_SYMBOLS_; ++i)
    {
//      jet_tree_pool_taylor[i] = (__typeof__(*jet_tree_pool_taylor)) malloc(1*sizeof(**jet_tree_pool_taylor));
//      if (jet_tree_pool_taylor[i]==NULL)
//        {
//          fprintf(stderr,"%s:%d Not enough memory\n",__FILE__,__LINE__);
//          fflush(stderr); exit(2);
//        }
      jet_tree_init_taylor(&jet_tree_pool_taylor[i]);
    }
  jet_tree_ipool_taylor = 0;
  }
  jet_tree_jaux_taylor=jet_tree_pool_taylor[0];
  
  jet_tree_flag_init_jet_library_taylor=1;
}

void jet_tree_clean_taylor(jet_tree_ptr_taylor s)
{
  if (s==NULL || *s==NULL) return;

  int j, k = _JET_COEFFICIENTS_COUNT_TOTAL_;
  __typeof__(*s) st, sf;
  for (st = *s, sf = st + _MAX_DEGREE_OF_JET_VARS_;
       st <= sf;
       ++st) {
    jet_tree_clean_taylor_node(st);
    /*free(st->coef); st->coef = NULL;*/
  }
  for (j = 0; j < k; ++j) {mycoef_clean((*s)->coef[j]);}
  free((*s)->coef); (*s)->coef = NULL;

  free(*s); *s = NULL;
}

void jet_tree_cleanup_taylor(void)
{
  if (jet_tree_flag_init_jet_library_taylor==0) return;
  {
  int i;
  for (i = 0; i <= 2*_NUMBER_OF_MAX_SYMBOLS_; ++i)
    {
      jet_tree_clean_taylor(&jet_tree_pool_taylor[i]);
//      free(jet_tree_pool_taylor[i]); jet_tree_pool_taylor[i]=NULL;
    }
  jet_tree_ipool_taylor = 0;
  free(jet_tree_pool_taylor); jet_tree_pool_taylor=NULL;
  }
//  jet_tree_clean_taylor(&jet_tree_jaux_taylor);
  mycoef_clean(jet_tree_caux_taylor);
  myfloat_clean(jet_tree_faux_taylor);
  mycoef_cleanup();
  jet_tree_nsymb_taylor = 0;
  jet_tree_deg_taylor = 0;
  jet_tree_flag_init_jet_library_taylor=0;
}

int jet_tree_get_num_symbs_taylor(void){return jet_tree_nsymb_taylor;}

int jet_tree_get_deg_taylor(void){return jet_tree_deg_taylor;}

int jet_tree_set_num_symbs_taylor(int nsymbs)
{
  fprintf(stderr,"%s:%d Action not allowed\n",__FILE__,__LINE__); fflush(stderr); exit(1);
  return 0;
}

int jet_tree_set_deg_taylor(int degree)
{
  int k=jet_tree_deg_taylor;
  if (degree > _MAX_DEGREE_OF_JET_VARS_) {
    fprintf(stderr,"%s:%d Invalid degree %d > %d\n",__FILE__,__LINE__,degree,_MAX_DEGREE_OF_JET_VARS_);
    fflush(stderr); exit(1);
  }
  jet_tree_deg_taylor = degree;
  return k;
}

void jet_tree_set_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a)
{
  if (s == a) return;

  __typeof__(s) st, at, sf;
  for (st = s, sf = st + jet_tree_deg_taylor, at= a;
       st <= sf;
       ++st, ++at){jet_tree_set_taylor_node(st,at);}
}

void jet_tree_set_zero_taylor(jet_tree_t_taylor s)
{
  __typeof__(s) st, sf;
  mycoef_t *hc, *hf;
  for (st = s, sf = st + jet_tree_deg_taylor;
       st <= sf; ++st)
  {jet_tree_set_zero_taylor_node(*st,hc,hf);}
}

void jet_tree_set_coef_taylor(jet_tree_t_taylor s, mycoef_t coef)
{
  // assert(s && *s);
  __typeof__(s) st, sf;

  jet_tree_set_coef_taylor_node(s,coef);
  for (st = s, sf = st + jet_tree_deg_taylor;
       st < sf;
       ++st, jet_tree_set_si_taylor_node(st,0)){}
}

void jet_tree_set_myfloat_taylor(jet_tree_t_taylor s, myfloat_t myf)
{
  __typeof__(s) st, sf;

  jet_tree_set_myfloat_taylor_node(s,myf);
  for (st = s, sf = st + jet_tree_deg_taylor;
       st < sf;
       ++st, jet_tree_set_si_taylor_node(st,0)){}
}

void jet_tree_set_d_taylor(jet_tree_t_taylor s, double d)
{
  __typeof__(s) st, sf;

  jet_tree_set_d_taylor_node(s,d);
  for (st = s, sf = st + jet_tree_deg_taylor;
       st < sf;
       ++st, jet_tree_set_si_taylor_node(st,0)){}
}


void jet_tree_set_si_taylor(jet_tree_t_taylor s, int d)
{
  __typeof__(s) st, sf;

  jet_tree_set_si_taylor_node(s,d);
  for (st = s, sf = st + jet_tree_deg_taylor;
       st < sf;
       ++st, jet_tree_set_si_taylor_node(st,0)){}
}
void jet_tree_set_coef_array_taylor(jet_tree_t_taylor s,mycoef_t *b)
{
  int i;

  for (i=0;i <_JET_COEFFICIENTS_COUNT_TOTAL_;
        b++, i++){mycoef_set( MY_JET_DATA(s,i) ,*b);}
}

void jet_tree_set_jet_2_coef_array_taylor(mycoef_t *b, jet_tree_t_taylor s)
{
 int i;

  for (i=0 ; i < _JET_COEFFICIENTS_COUNT_TOTAL_;
        b++, i++){mycoef_set(*b, MY_JET_DATA(s,i));}
}

myfloat_t* jet_tree_to_myfloat_taylor(jet_tree_t_taylor s)
{  return mycoef_to_myfloat(*jet_tree_get_zero_coef_taylor_node(s));}

mycoef_t* jet_tree_get_coef_taylor(jet_tree_t_taylor s, const int idx[])
{
  int i, k;
  for (i = 0, k = 0; i < s->nsymb; k += idx[i], ++i){}
  
  return jet_tree_get_coef_taylor_node(s+k, idx);
}

mycoef_t* jet_tree_coef0_taylor(jet_tree_t_taylor s)
{  return jet_tree_get_zero_coef_taylor_node(s);}
mycoef_t* jet_tree_coef1_taylor(jet_tree_t_taylor s, int i)
{
  int k, idx[s->nsymb];
  for (k = 0; k < s->nsymb; ++k){idx[k]=0;}
  idx[i]=1;
  return jet_tree_get_coef_taylor(s,idx);
}

void jet_tree_nrminf_taylor(myfloat_t nrm[1], jet_tree_t_taylor s)
{
  __typeof__(s) st, sf;
  /* WARNING initial value for nrm GIVEN!! */
  for (st = s, sf = st + jet_tree_deg_taylor;
       st <= sf;
       ++st){jet_tree_nrminf_taylor_node(nrm,st);}
}

void jet_tree_nrm2_taylor(myfloat_t nrm[1], jet_tree_t_taylor s)
{
  __typeof__(s) st, sf;
  /* WARNING initial value for nrm GIVEN!! */
  for (st = s, sf = st + jet_tree_deg_taylor;
       st <= sf;
       ++st){jet_tree_nrm2_taylor_node(nrm,st);}
  myfloat_set_sqrt(*nrm,*nrm);
}

void jet_tree_neg_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a )
{
  // assert(s && a); // assert(s->nsymb == a->nsymb); // assert(deg == deg);
  // assert(*s && *a);

  __typeof__(s) st, at, sf;
  for (st = s, sf = st + jet_tree_deg_taylor, at = a;
       st <= sf;
       ++st, ++at){jet_tree_neg_taylor_node(st,at);}
}

void jet_tree_add2_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, jet_tree_t_taylor b)
{
  // assert(s && a && b);

  int i;
  for (i = 0; i <= jet_tree_deg_taylor; ++i) {jet_tree_add2_taylor_node(s+i, a+i, b+i);}
}

void jet_tree_sub2_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, jet_tree_t_taylor b)
{
  // assert(s && a && b);

  int i;
  for (i = 0; i <= jet_tree_deg_taylor; ++i) {jet_tree_sub2_taylor_node(s+i, a+i, b+i);}
}

void jet_tree_set_sq_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a)
{
  // assert(s && a); // assert(s != a);
  // assert(*s && *a);

  mycoef_t *a0, *sc, *sf;
  sc = jet_tree_get_zero_coef_taylor_node(s);
  a0 = jet_tree_get_zero_coef_taylor_node(a);
  mycoef_mul2((*sc),(*a0),(*a0));

  int i, j, k, ord=jet_tree_deg_taylor;
  if (ord % 2)
    {
      i = ord;
      /* odd case */
      jet_tree_set_zero_taylor_node(s[i], sc,sf);
      k = i/2;
      for (j = 0; j <= k; ++j) jet_tree_pph_taylor_node(s+i, a+j, a+(i-j));
      jet_tree_mul2_si_taylor_node(s[i], s[i], 2, sc,sf,a0);
      --ord;
    }
  for (i = 1; i <= ord; ++i)
    {
       /* odd case */
      jet_tree_set_zero_taylor_node(s[i], sc,sf);
      k = i/2;
      for (j = 0; j <= k; ++j) jet_tree_pph_taylor_node(s+i, a+j, a+(i-j));
      jet_tree_mul2_si_taylor_node(s[i], s[i], 2, sc,sf,a0);

      ++i;

      /* even case */
      jet_tree_set_zero_taylor_node(s[i], sc,sf);
      k = i/2;
      for (j = 0; j < k; ++j) jet_tree_pph_taylor_node(s+i, a+j, a+(i-j));
      jet_tree_mul2_si_taylor_node(s[i], s[i], 2, sc,sf,a0);
      jet_tree_pph_taylor_node(s+i, a + k, a + k);
    }
}

void jet_tree_mul2_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, jet_tree_t_taylor b)
{
// assert(s && a && b); // assert(s != a && s != b);
// assert(*s && *a && *b);
  int i, j;
  mycoef_t *sc,*sf;

  if (a == b) {jet_tree_set_sq_taylor(s,a); return;}
  for (i = 0; i <= jet_tree_deg_taylor; ++i)
    {
      jet_tree_set_zero_taylor_node(s[i], sc,sf);
      for (j = 0; j <= i; ++j)
        {jet_tree_pph_taylor_node(s+i, a+j, b+(i-j));}
    }
}

void jet_tree_div2_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, jet_tree_t_taylor b)
{
  // assert(s && a && b); // assert(s != b);
  // assert(*s && *a && *b);
  mycoef_t *b0, *sc,*sf,*sc1;
  int i, j;
  sc = jet_tree_get_zero_coef_taylor_node(a);
  b0 = jet_tree_get_zero_coef_taylor_node(b);
  sf = jet_tree_get_zero_coef_taylor_node(s);
  mycoef_div2(*sf,*sc,*b0);
  for (i = 1; i <= jet_tree_deg_taylor; ++i)
    {
      jet_tree_set_taylor_node(s+i, a+i);
      for (j = 0; j < i; ++j) {jet_tree_mph_taylor_node(s+i, s+j, b + (i-j));}
      jet_tree_div2_coef_taylor_node(s[i], s[i],(*b0), sc,sf,sc1);
    }
}

void jet_tree_add2_coef_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, mycoef_t b)
{
  __typeof__(s) st, at, sf = s + jet_tree_deg_taylor;
  mycoef_add2(*(s->coef),*(a->coef),b);
  if (s != a) for (st = s, at = a;
       st < sf; ++st, ++at, jet_tree_set_taylor_node(st,at)){}
}

void jet_tree_sub2_coef_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, mycoef_t b)
{
  __typeof__(s) st, at, sf = s + jet_tree_deg_taylor;
  mycoef_sub2(*(s->coef),*(a->coef),b);
  if (s != a) for (st = s, at = a;
       st < sf; 
       ++st, ++at, jet_tree_set_taylor_node(st,at)){}
}

void jet_tree_coef_sub2_taylor(jet_tree_t_taylor s, mycoef_t b, jet_tree_t_taylor a)
{
  __typeof__(s) st, at, sf = s + jet_tree_deg_taylor;
  mycoef_sub2(*(s->coef),b,*(a->coef));
  for (st = s, at= a;
       st < sf; 
       ++st, ++at, jet_tree_neg_taylor_node(st,at)){}
}

void jet_tree_mul2_coef_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, mycoef_t b)
{
  int k;
  mycoef_t *sc, *scf, *ac;
  for (k = 0; k <= jet_tree_deg_taylor; ++k)
  {jet_tree_mul2_coef_taylor_node(s[k],a[k],b, sc,scf,ac);}
}

void jet_tree_div2_coef_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, mycoef_t b)
{
  // assert(s && a);
  // assert(coef);

  mycoef_t *sc, *scf, *ac;
  __typeof__(s) st, sf, at;
  for (st = s, sf = st + jet_tree_deg_taylor, at= a;
       st <= sf;
       ++st, ++at) {jet_tree_div2_coef_taylor_node(st[0], at[0], b, sc,scf,ac);}
}

void jet_tree_coef_div2_taylor(jet_tree_t_taylor s, mycoef_t b, jet_tree_t_taylor a)
{
  // assert(s && a); // assert(s != a);
  // assert(coef);
  mycoef_t *a0, *sc,*sf,*sc1;
  int i, j;
  a0 = jet_tree_get_zero_coef_taylor_node(a);
  sf = jet_tree_get_zero_coef_taylor_node(s);
  mycoef_div2(*sf,b,*a0);
  for (i = 1; i <= jet_tree_deg_taylor; ++i)
    {
      jet_tree_set_zero_taylor_node(s[i], sc,sf);
      for (j = 0; j < i; ++j) {jet_tree_mph_taylor_node(s+i, s+j, a+(i-j));}
      jet_tree_div2_coef_taylor_node(s[i], s[i],(*a0), sc,sf,sc1);
    }
}


void jet_tree_add2_myfloat_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, myfloat_t b)
{
  __typeof__(s) st, at, sf = s + jet_tree_deg_taylor;
  mycoef_add2_myfloat(*(s->coef),*(a->coef),b);
  if (s != a) for (st = s, at = a;
       st < sf; ++st, ++at, jet_tree_set_taylor_node(st,at)){}
}

void jet_tree_sub2_myfloat_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, myfloat_t b)
{
  __typeof__(s) st, at, sf = s + jet_tree_deg_taylor;
  mycoef_sub2_myfloat(*(s->coef),*(a->coef),b);
  if (s != a) for (st = s, at = a;
       st < sf; 
       ++st, ++at, jet_tree_set_taylor_node(st,at)){}
}

void jet_tree_myfloat_sub2_taylor(jet_tree_t_taylor s, myfloat_t b, jet_tree_t_taylor a)
{
  __typeof__(s) st, at, sf = s + jet_tree_deg_taylor;
  mycoef_myfloat_sub2(*(s->coef),b,*(a->coef));
  for (st = s, at= a;
       st < sf; 
       ++st, ++at, jet_tree_neg_taylor_node(st,at)){}
}

void jet_tree_mul2_myfloat_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, myfloat_t b)
{
  int k;
  mycoef_t *sc, *scf, *ac;
  for (k = 0; k <= jet_tree_deg_taylor; ++k)
  {jet_tree_mul2_myfloat_taylor_node(s[k],a[k],b, sc,scf,ac);}
}

void jet_tree_div2_myfloat_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, myfloat_t b)
{
  mycoef_t *sc, *scf, *ac;
  __typeof__(s) st, sf, at;
  for (st = s, sf = st + jet_tree_deg_taylor, at= a;
       st <= sf;
       ++st, ++at) {jet_tree_div2_myfloat_taylor_node(st[0], at[0], b, sc,scf,ac);}
}

void jet_tree_myfloat_div2_taylor(jet_tree_t_taylor s, myfloat_t b, jet_tree_t_taylor a)
{
  mycoef_t *a0, *sc,*sf,*sc1;
  int i, j;
  a0 = jet_tree_get_zero_coef_taylor_node(a);
  sf = jet_tree_get_zero_coef_taylor_node(s);
  mycoef_myfloat_div2(*sf,b,*a0);
  for (i = 1; i <= jet_tree_deg_taylor; ++i)
    {
      jet_tree_set_zero_taylor_node(s[i], sc,sf);
      for (j = 0; j < i; ++j) {jet_tree_mph_taylor_node(s+i, s+j, a+(i-j));}
      jet_tree_div2_coef_taylor_node(s[i], s[i],(*a0), sc,sf,sc1);
    }
}


void jet_tree_add2_d_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, double b)
{
  __typeof__(s) st, at, sf = s + jet_tree_deg_taylor;
  mycoef_add2_d(*(s->coef),*(a->coef),b);
  if (s != a) for (st = s, at = a;
       st < sf; ++st, ++at, jet_tree_set_taylor_node(st,at)){}
}

void jet_tree_sub2_d_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, double b)
{
  __typeof__(s) st, at, sf = s + jet_tree_deg_taylor;
  mycoef_sub2_d(*(s->coef),*(a->coef),b);
  if (s != a) for (st = s, at = a;
       st < sf; 
       ++st, ++at, jet_tree_set_taylor_node(st,at)){}
}

void jet_tree_d_sub2_taylor(jet_tree_t_taylor s, double b, jet_tree_t_taylor a)
{
  fprintf(stderr,"%s:%d to implement\n",__FILE__,__LINE__); exit(1);
}

void jet_tree_mul2_d_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, double b)
{
  int k;
  mycoef_t *sc, *scf, *ac;
  for (k = 0; k <= jet_tree_deg_taylor; ++k)
  {jet_tree_mul2_d_taylor_node(s[k],a[k],b, sc,scf,ac);}
}

void jet_tree_div2_d_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, double b)
{
  fprintf(stderr,"%s:%d to implement\n",__FILE__,__LINE__); exit(1);
}

void jet_tree_d_div2_taylor(jet_tree_t_taylor s, double b, jet_tree_t_taylor a)
{
  mycoef_t *a0, *sc,*sf,*sc1;
  int i, j;
  a0 = jet_tree_get_zero_coef_taylor_node(a);
  sf = jet_tree_get_zero_coef_taylor_node(s);
  mycoef_d_div2(*sf,b,*a0);
  for (i = 1; i <= jet_tree_deg_taylor; ++i)
    {
      jet_tree_set_zero_taylor_node(s[i], sc,sf);
      for (j = 0; j < i; ++j) {jet_tree_mph_taylor_node(s+i, s+j, a+(i-j));}
      jet_tree_div2_coef_taylor_node(s[i], s[i],(*a0), sc,sf,sc1);
    }
}

void jet_tree_add2_si_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, int b)
{
  __typeof__(s) st, at, sf = s + jet_tree_deg_taylor;
  mycoef_add2_si(*(s->coef),*(a->coef),b);
  if (s != a) for (st = s, at = a;
       st < sf; ++st, ++at, jet_tree_set_taylor_node(st,at)){}
}

void jet_tree_sub2_si_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, int b)
{
  __typeof__(s) st, at, sf = s + jet_tree_deg_taylor;
  mycoef_sub2_si(*(s->coef),*(a->coef),b);
  if (s != a) for (st = s, at = a;
       st < sf; 
       ++st, ++at, jet_tree_set_taylor_node(st,at)){}
}

void jet_tree_si_sub2_taylor(jet_tree_t_taylor s, int b, jet_tree_t_taylor a)
{
  __typeof__(s) st, at, sf = s + jet_tree_deg_taylor;
  mycoef_si_sub2(*(s->coef),b,*(a->coef));
  for (st = s, at= a;
       st < sf; 
       ++st, ++at, jet_tree_neg_taylor_node(st,at)){}
//  fprintf(stderr,"%s:%d to test\n",__FILE__,__LINE__); exit(1);
}

void jet_tree_mul2_si_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, int b)
{
  int k;
  mycoef_t *sc, *scf, *ac;
  for (k = 0; k <= jet_tree_deg_taylor; ++k)
  {jet_tree_mul2_si_taylor_node(s[k],a[k],b, sc,scf,ac);}
}

void jet_tree_div2_si_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, int b)
{
  mycoef_t *sc, *scf, *ac;
  __typeof__(s) st, sf, at;
  for (st = s, sf = st + jet_tree_deg_taylor, at= a;
       st <= sf;
       ++st, ++at) {jet_tree_div2_si_taylor_node(st[0], at[0], b, sc,scf,ac);}
}

void jet_tree_si_div2_taylor(jet_tree_t_taylor s, int b, jet_tree_t_taylor a)
{
  mycoef_t *a0, *sc,*sf,*sc1;
  int i, j;
  a0 = jet_tree_get_zero_coef_taylor_node(a);
  sf = jet_tree_get_zero_coef_taylor_node(s);
  mycoef_si_div2(*sf,b,*a0);
  for (i = 1; i <= jet_tree_deg_taylor; ++i)
    {
      jet_tree_set_zero_taylor_node(s[i], sc,sf);
      for (j = 0; j < i; ++j) {jet_tree_mph_taylor_node(s+i, s+j, a+(i-j));}
      jet_tree_div2_coef_taylor_node(s[i], s[i],(*a0), sc,sf,sc1);
    }
}

void jet_tree_set_sqrt_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a)
{
  // assert(s && a);
  // assert(*s && *a);

  mycoef_t *s0,*sc,*scf,*sc2;
  s0 = jet_tree_get_zero_coef_taylor_node(s);
  mycoef_set_sqrt((*s0), *jet_tree_get_zero_coef_taylor_node(a)); // assert(fabs(*s0) > ZERO_TOL);

  int i, j, k;
  for (i = 1; i <= jet_tree_deg_taylor; ++i)
    {
       /* odd case */
      jet_tree_set_taylor_node(s+i, a+i);
      jet_tree_div2_si_taylor_node(s[i], s[i], 2, sc,scf,sc2);
      k = i/2;
      for (j = 1; j <= k; ++j) jet_tree_mph_taylor_node(s+i, s+j, s+(i-j));
      jet_tree_div2_coef_taylor_node(s[i], s[i], *s0, sc,scf,sc2);

      if (++i > jet_tree_deg_taylor) break;

      /* even case */
      jet_tree_set_taylor_node(s+i, a+i);
      k = i/2;
      jet_tree_mph_taylor_node(s+i, s+k, s+k);
      jet_tree_div2_si_taylor_node(s[i], s[i], 2, sc,scf,sc2);
      for (j = 1; j < k; ++j) jet_tree_mph_taylor_node(s+i, s+j, s+(i-j));
      jet_tree_div2_coef_taylor_node(s[i], s[i], *s0, sc,scf,sc2);
    }
}

void jet_tree_set_pow_myfloat_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a, myfloat_t myf)
{
  // assert(s && a); // assert(s != a);
//  if (myf == 2)     {jet_tree_set_sq_taylor(s,a); return;}
//  if (myf == 0.5e0) {jet_tree_set_sqrt_taylor(s,a); return;}
  // assert(*s && *a);

  mycoef_t *a0, *s0, *tmp, *sc,*sf,*sc1;
  tmp = jet_tree_get_zero_coef_taylor_node(jet_tree_jaux_taylor);
  sc = jet_tree_get_zero_coef_taylor_node(s);
  a0 = jet_tree_get_zero_coef_taylor_node(a); // assert(fabs(*a0) > ZERO_TOL);
  mycoef_set_pow_myfloat((*sc), *a0, myf);

  int i, j;
  for (i = 1; i <= jet_tree_deg_taylor; ++i)
    {
      jet_tree_set_zero_taylor_node(s[i], sc,sf);
      for (j = 0; j < i; ++j) {
        myfloat_mul2_si(jet_tree_faux_taylor,myf,i-j);
        myfloat_sub2_si(jet_tree_faux_taylor,jet_tree_faux_taylor,j);
        jet_tree_pph_myfloat_taylor_node(s+i, jet_tree_faux_taylor, a+(i-j), s+j);
      }
      mycoef_mul2_si(*tmp,*a0,i);
      jet_tree_div2_coef_taylor_node(s[i], s[i], (*tmp), sc,sf,sc1);
    }
}

void jet_tree_set_exp_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a)
{
  // assert(s && a); // assert(s != a);
  // assert(*s && *a);

  mycoef_t *s0,*scf,*sc;
  s0 = jet_tree_get_zero_coef_taylor_node(s);
  mycoef_set_exp((*s0), *jet_tree_get_zero_coef_taylor_node(a));

  int i, j;
  for (i = 1; i <= jet_tree_deg_taylor; ++i)
    {
      jet_tree_set_zero_taylor_node(s[i], sc,scf);
      for (j = 0; j < i; ++j)
      {jet_tree_pph_si_taylor_node(s+i, i-j, a+(i-j), s+j);}
      jet_tree_div2_si_taylor_node(s[i], s[i], i, sc,scf,s0);
    }
}

void jet_tree_set_log_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a)
{
  // assert(s && a); // assert(s != a);
  // assert(*s && *a);

  mycoef_t *a0, *sc,*sf,*sc1;
  sc = jet_tree_get_zero_coef_taylor_node(s);
  a0 = jet_tree_get_zero_coef_taylor_node(a);
  mycoef_set_log((*sc), *jet_tree_get_zero_coef_taylor_node(a));

  int i, j;
  for (i = 1; i <= jet_tree_deg_taylor; ++i)
    {
      jet_tree_set_taylor_node(s+i, a+i);
      for (j = 1; j < i; ++j) {
        myfloat_set_si(jet_tree_faux_taylor, -j);
        myfloat_div2_si(jet_tree_faux_taylor, jet_tree_faux_taylor, i);
        jet_tree_pph_myfloat_taylor_node(s+i, jet_tree_faux_taylor, a+(i-j), s+j);
      }
      jet_tree_div2_coef_taylor_node(s[i], s[i], *a0, sc,sf,sc1);
    }
}

#define jet_tree_sincos_taylor(s,c,a)\
{\
  /* assert(s && c && a); assert(s != a && s != c && c != a);*/\
  /* assert(*s && *c && *a);*/\
\
  int i, j;\
  myfloat_t aux1,aux2;\
  mycoef_t *a0, *sc, *sf;\
  myfloat_init(aux1);\
  myfloat_init(aux2);\
  a0 = jet_tree_get_zero_coef_taylor_node(a);\
  mycoef_set_sin((*jet_tree_get_zero_coef_taylor_node(s)),(*a0));\
  mycoef_set_cos((*jet_tree_get_zero_coef_taylor_node(c)),(*a0));\
\
  for (i = 1; i <= jet_tree_deg_taylor; ++i)\
    {\
      jet_tree_set_zero_taylor_node((s)[i], sc,sf);\
      jet_tree_set_zero_taylor_node((c)[i], sc,sf);\
\
      for (j = 0; j < i; ++j)\
        {\
          myfloat_set_si(aux1,j);\
          myfloat_div2_si(aux1,aux1,i);\
          myfloat_sub2_si(aux2,aux1,1);\
          myfloat_si_sub2(aux1,1,aux1);\
\
          jet_tree_pph_myfloat_taylor_node((s)+i, aux1, (a)+(i-j), (c)+j);\
          jet_tree_pph_myfloat_taylor_node((c)+i, aux2, (a)+(i-j), (s)+j);\
        }\
    }\
  myfloat_clean(aux2);\
  myfloat_clean(aux1);\
}\

void jet_tree_set_sin_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a)
{
  jet_tree_sincos_taylor(s,jet_tree_jaux_taylor,a);
}

void jet_tree_set_cos_taylor(jet_tree_t_taylor c, jet_tree_t_taylor a)
{
  jet_tree_sincos_taylor(jet_tree_jaux_taylor,c,a);
}

void jet_tree_set_tan_taylor(jet_tree_t_taylor t, jet_tree_t_taylor a)
{
  int j,k,ii,jj ,nk;
  mycoef_t *t0,*tcf,*tc;
  mycoef_set_tan(*jet_tree_get_zero_coef_taylor_node(t),*jet_tree_get_zero_coef_taylor_node(a));
  mycoef_mul2(*jet_tree_get_zero_coef_taylor_node(jet_tree_jaux_taylor),*jet_tree_get_zero_coef_taylor_node(t),*jet_tree_get_zero_coef_taylor_node(t));

  nk = (jet_tree_deg_taylor+1) - ((jet_tree_deg_taylor+1)%2==0);
  for (k = 1; k < nk; k++) {
    jet_tree_set_zero_taylor_node(t[k], tc,tcf);
    for (j = 0; j < k; j++) 
    {jet_tree_pph_si_taylor_node(t+k,k-j,a+(k-j),jet_tree_jaux_taylor+j);}
    jet_tree_div2_si_taylor_node(t[k],t[k],k, tc,tcf,t0);
    jet_tree_add2_taylor_node(t+k,t+k,a+k);

    /* k odd */
    jet_tree_set_zero_taylor_node(jet_tree_jaux_taylor[k], tc,tcf);
    for (j = 0; j <= (k-1)/2; j++)
    {jet_tree_pph_taylor_node(jet_tree_jaux_taylor+k,t+j,t+(k-j));}
    jet_tree_mul2_si_taylor_node(jet_tree_jaux_taylor[k],jet_tree_jaux_taylor[k],2, tc,tcf,t0);

    ++k;

    jet_tree_set_zero_taylor_node(t[k], tc,tcf);
    for (j = 0; j < k; j++) 
    {jet_tree_pph_si_taylor_node(t+k,k-j,a+(k-j),jet_tree_jaux_taylor+j);}
    jet_tree_div2_si_taylor_node(t[k],t[k],k, tc,tcf,t0);
    jet_tree_add2_taylor_node(t+k,t+k,a+k);

    /* k even */
    jet_tree_set_zero_taylor_node(jet_tree_jaux_taylor[k], tc,tcf);
    for (j = 0; j <= (k-2)/2; j++)
    {jet_tree_pph_taylor_node(jet_tree_jaux_taylor+k,t+j,t+(k-j));}
    jet_tree_mul2_si_taylor_node(jet_tree_jaux_taylor[k],jet_tree_jaux_taylor[k],2, tc,tcf,t0);

    j = k/2;
    jet_tree_pph_taylor_node(jet_tree_jaux_taylor+k,t+j,t+j);
  }
  if ((jet_tree_deg_taylor+1)%2==0) {
    k = jet_tree_deg_taylor;
    jet_tree_set_zero_taylor_node(t[k], tc,tcf);
    for (j = 0; j < k; j++) 
    {jet_tree_pph_si_taylor_node(t+k,k-j,a+(k-j),jet_tree_jaux_taylor+j);}
    jet_tree_div2_si_taylor_node(t[k],t[k],k, tc,tcf,t0);
    jet_tree_add2_taylor_node(t+k,t+k,a+k);
  }

//  fprintf(stderr,"%s:%d to test\n",__FILE__,__LINE__); exit(1);
}
void jet_tree_set_atan_taylor(jet_tree_t_taylor t, jet_tree_t_taylor a)
{
  int j,k,ii,jj;
  mycoef_t *t0,*tcf,*tc;
  mycoef_set_atan(*jet_tree_get_zero_coef_taylor_node(t),*jet_tree_get_zero_coef_taylor_node(a));
  jet_tree_set_sq_taylor(jet_tree_jaux_taylor,a);
  jet_tree_add2_si_taylor(jet_tree_jaux_taylor,jet_tree_jaux_taylor,1);
  for (k = 1; k <= jet_tree_deg_taylor; k++) {
    jet_tree_set_zero_taylor_node(t[k], tc,tcf);
    for (j = 1; j < k; j++) 
    {jet_tree_pph_si_taylor_node(t+k, j, jet_tree_jaux_taylor+(k-j), t+j);}
    jet_tree_div2_si_taylor_node(t[k],t[k],k, tc,tcf,t0);
    jet_tree_sub2_taylor_node(t+k,a+k,t+k);
    jet_tree_div2_coef_taylor_node(t[k],t[k],*jet_tree_get_zero_coef_taylor_node(jet_tree_jaux_taylor), tc,tcf,t0);
  }
//  fprintf(stderr,"%s:%d to test\n",__FILE__,__LINE__); exit(1);
}

#define jet_tree_sinhcosh_taylor(s,c,a)\
{\
  /* assert(s && c && a); assert(s != a && s != c && c != a);*/\
  /* assert(*s && *c && *a);*/\
\
  int i, j;\
  myfloat_t aux1;\
  mycoef_t *a0, *sc,*sf;\
  myfloat_init(aux1);\
  a0 = jet_tree_get_zero_coef_taylor_node(a);\
  mycoef_set_sinh((*jet_tree_get_zero_coef_taylor_node(s)),(*a0));\
  mycoef_set_cosh((*jet_tree_get_zero_coef_taylor_node(c)),(*a0));\
\
  for (i = 1; i <= jet_tree_deg_taylor; ++i)\
    {\
      jet_tree_set_zero_taylor_node(s[i], sc,sf);\
      jet_tree_set_zero_taylor_node(c[i], sc,sf);\
\
      for (j = 0; j < i; ++j)\
        {\
          myfloat_set_si(aux1,j);\
          myfloat_div2_si(aux1,aux1,i);\
          myfloat_si_sub2(aux1,1,aux1);\
\
          jet_tree_pph_myfloat_taylor_node(s+i, aux1, a+(i-j), c+j);\
          jet_tree_pph_myfloat_taylor_node(c+i, aux1, a+(i-j), s+j);\
        }\
    }\
  myfloat_clean(aux1);\
}\

void jet_tree_set_sinh_taylor(jet_tree_t_taylor s, jet_tree_t_taylor a)
{
  jet_tree_sinhcosh_taylor(s,jet_tree_jaux_taylor,a);
}

void jet_tree_set_cosh_taylor(jet_tree_t_taylor c, jet_tree_t_taylor a)
{
  jet_tree_sinhcosh_taylor(jet_tree_jaux_taylor,c,a);
}

void jet_tree_eval_taylor(mycoef_t val[1], jet_tree_t_taylor x, myfloat_t s[])
{
  int k, m;
  mycoef_set_zero(*val);
  for (k = jet_tree_deg_taylor; k > 0; --k) {
    jet_tree_sumeval_taylor_node(val, x + k, s);
    /* TODO possible memory improvement... */
  }
  mycoef_add2(*val,*val, *(jet_tree_get_zero_coef_taylor_node(x)));
}

/* special functions */

static jet_tree_t_taylor jet_tree_compoh_taylor_node(jet_tree_ptr_taylor_node h, jet_tree_t_taylor *v)
{
  int n, k, m;
  jet_tree_t_taylor x1, xk, tmp1, tmp2;
  
  n = h->nsymb;
  k = h->deg;
  x1 = v[n-1];
  
  if (k == 0) {
    tmp1 = jet_tree_pool_taylor[jet_tree_ipool_taylor]; ++jet_tree_ipool_taylor;
    jet_tree_set_coef_taylor(tmp1, *(h->coef));
  } else if (n==1) {
    tmp1 = jet_tree_pool_taylor[jet_tree_ipool_taylor]; ++jet_tree_ipool_taylor;
    xk = jet_tree_pool_taylor[jet_tree_ipool_taylor]; ++jet_tree_ipool_taylor;
    jet_tree_set_taylor(xk, x1);
    for (m = 1; m < k; ++m)
      {
        /* xk = xk * x1 */
        jet_tree_mul2_taylor(tmp1, xk, x1);
//        aprods(tmp1, xk, x1);
        
        tmp2 = xk;
        xk = tmp1;
        tmp1 = tmp2;
      }
    jet_tree_mul2_coef_taylor(xk, xk, *(h->coef));
    jet_tree_pool_taylor[--jet_tree_ipool_taylor] = tmp1;
    return xk;
  } else {
      xk = jet_tree_pool_taylor[jet_tree_ipool_taylor]; ++jet_tree_ipool_taylor;
      tmp1 = jet_tree_compoh_taylor_node((h->term)+k, v);
      for (m = k; m > 0; --m)
        {
          jet_tree_mul2_taylor(xk, tmp1, x1);
//          aprods(xk, tmp1, x1);
          jet_tree_pool_taylor[--jet_tree_ipool_taylor] = tmp1;
          tmp1 = jet_tree_compoh_taylor_node((h->term) + m-1, v);
          jet_tree_add2_taylor(tmp1, tmp1, xk);
        }
      jet_tree_pool_taylor[--jet_tree_ipool_taylor] = xk;
    }
  return tmp1;
//  fprintf(stderr, "%s:%d to implement\n", __FILE__, __LINE__); fflush(stderr); exit(1);
}

/* Given u(s1,...,sd) and v=(v1,...,vd)
 * series vector of d variables.
 * It outputs w = u(v1,...,vd) serie of d variables.
 * 
 * Note: It allocates a pool of d+1 series possibly
 *  given auxiliary parameter
 */

void jet_tree_compo_taylor(jet_tree_t_taylor w, jet_tree_t_taylor u, jet_tree_t_taylor *v)
{
  int m, k;
  jet_tree_t_taylor tmp=NULL;
  
  k = jet_tree_get_deg_taylor();
  jet_tree_set_zero_taylor(w);
  for (m = k; m > 0; --m)
    {
      tmp = jet_tree_compoh_taylor_node(u+m, v);
      jet_tree_add2_taylor(w, w, tmp);
      jet_tree_pool_taylor[--jet_tree_ipool_taylor] = tmp;
    }
  mycoef_add2(*jet_tree_get_zero_coef_taylor_node(w),*jet_tree_get_zero_coef_taylor_node(w),*jet_tree_get_zero_coef_taylor_node(u));
}
void jet_tree_reverse_taylor(jet_tree_t_taylor *u, jet_tree_t_taylor *v)
{
  int m, n, k, i, ns = _NUMBER_OF_MAX_SYMBOLS_;
  jet_tree_t_taylor tmp=NULL, *tmp2=&jet_tree_pool_taylor[ns+1];
  
  for (i = 0; i < ns; ++i)
    {
      jet_tree_set_zero_taylor(u[i]);
      jet_tree_set_taylor_node(&u[i][0], &v[i][0]);
      jet_tree_set_taylor_node(&u[i][1], &v[i][1]);
      
      jet_tree_set_zero_taylor(tmp2[i]);
    }
  
  jet_tree_ipool_taylor = 0;
  k = jet_tree_get_deg_taylor();
  for (m = 2; m <= k; ++m)
    {
      for (n = m; n > 0; --n) for (i = 0; i < ns; ++i)
        {
          tmp = jet_tree_compoh_taylor_node(&v[i][n], u);
          jet_tree_add2_taylor(tmp2[i], tmp2[i], tmp); /* it could just be homog */
          jet_tree_pool_taylor[--jet_tree_ipool_taylor] = tmp;
        }
      for (i = 0; i < ns; ++i)
        {
          jet_tree_set_taylor_node(&u[i][m], &tmp2[i][m]);
          jet_tree_neg_taylor_node(&u[i][m], &u[i][m]);
          jet_tree_set_zero_taylor(tmp2[i]);
        }
    }
}
void jet_tree_algT_taylor(jet_tree_t_taylor *w, jet_tree_t_taylor *u, jet_tree_t_taylor *v)
{
  int m, n, k, i, ns = _NUMBER_OF_MAX_SYMBOLS_;
  jet_tree_t_taylor tmp=NULL, *tmp2=&jet_tree_pool_taylor[ns+1];
  
  for (i = 0; i < ns; ++i)
    {
      jet_tree_set_zero_taylor(w[i]);
//      jet_tree_set_zero_taylor_node(&w[i][0]);
      jet_tree_set_taylor_node(&w[i][1], &u[i][1]);
      
      jet_tree_set_zero_taylor(tmp2[i]);
    }
  
  jet_tree_ipool_taylor = 0;
  k = jet_tree_get_deg_taylor();
  for (m = 2; m <= k; ++m)
    {
      for (n = m; n > 0; --n) for (i = 0; i < ns; ++i)
        {
          tmp = jet_tree_compoh_taylor_node(&v[i][n], w);
          jet_tree_add2_taylor(tmp2[i], tmp2[i], tmp); /* it could just be homog */
          jet_tree_pool_taylor[--jet_tree_ipool_taylor] = tmp;
        }
      for (i = 0; i < ns; ++i)
        {
          jet_tree_set_taylor_node(&w[i][m], &u[i][m]);
          jet_tree_sub2_taylor_node(&w[i][m], &w[i][m], &tmp2[i][m]);
          jet_tree_set_zero_taylor(tmp2[i]);
        }
    }
}

void jet_tree_fprintf_taylor(FILE *file, const char *fmt, jet_tree_t_taylor s)
{
  int i;
  for (i=0;i <_JET_COEFFICIENTS_COUNT_TOTAL_; i++){mycoef_fprintf(file, fmt, MY_JET_DATA(s,i));}
}

void jet_tree_fscanf_taylor(FILE *file, const char *fmt, jet_tree_t_taylor s)
{
  int i;
  for (i=0;i <_JET_COEFFICIENTS_COUNT_TOTAL_; i++){mycoef_fscanf(file, fmt, MY_JET_DATA(s,i));}
}
void jet_tree_genidx_taylor(int c[], int n)
{
  int deg, i, in;
  for (in = 0; in < n; ++in) if (c[in] != 0) break;
  if (in == n) return;
  if (in == n-1) { c[0] = c[n-1]; c[n-1] = 0; return; }
  deg = c[in]+c[in+1];
  c[in+1]++;
  for (i = 1; i <= in; ++i) c[i] = 0;
  c[0] = deg-c[in+1];
}

static char *jet_tree_sscanf4_taylor(char *ptr, const char *myfmt, jet_tree_t_taylor s, int *l)
{
  int i;
  for (i = 0; i <_JET_COEFFICIENTS_COUNT_TOTAL_ && *ptr!='\0'; i++){
    ptr = mycoef_sscanf4(ptr, myfmt, MY_JET_DATA(s,i), l);
  }
  for ( ; i <_JET_COEFFICIENTS_COUNT_TOTAL_; i++) {mycoef_set_zero(MY_JET_DATA(s,i));}
  return ptr;
}
void jet_tree_sscanf_taylor(const char *str, const char *fmt, jet_tree_t_taylor s)
{
  int l;
  const int len=fmt?strnlen(fmt,128):0; /* NOTE: safety string length of 128 */
  char myfmt[len+3], *mystr = strdup(str);
  sprintf(myfmt, "%s%%n",fmt);
  jet_tree_sscanf4_taylor(mystr, myfmt, s, &l);
  free(mystr);
}


/* END CODE jet_tree_t_taylor */

/***********************************************************************
 *
 * Procedure generated by the TAYLOR translator. Do not edit!
 *
 * It needs the header file 'taylor.h' to compile.
 * Run taylor with the -header -o taylor.h option to generate a sample 'taylor.h'

 * Translation info is at the end of this file.
 * Version 2.1, May 26, 2023
 ***********************************************************************/

#include <stdio.h>
#include <stdlib.h>
MY_FLOAT **taylor_coefficients_taylor_A(MY_FLOAT t, MY_FLOAT *x, int order, int rflag, MY_JET *sIn, MY_JET ***sOut)
{
   /* input: 
      t:     current value of the time variable 
      x:     array represent values of the state variables
      order: order of the taylor coefficients sought
      rflag: recompute flag. If you call this routine with one order 
             first, but then decided that you need a higher order of the
             taylor polynomial, you can pass 0 to rflag. This routine 
             will try to use the values already computed. Provided that 
             both x and t have not been changed, and you did not modify 
             the jet derivatives from the previous call.
      sIn:   array representing the input jet variables
             If NULL, the x values are assigned.
      sOut:  Pointer output jet variables
             If NULL, the pointer is not modified.
      Return Value:
            Two D Array, rows are the taylor coefficients of the
            state variables

     */
    extern MY_FLOAT s;
    extern MY_FLOAT w;
    extern MY_FLOAT q;
    extern MY_FLOAT fff;

    static MY_FLOAT     *_jz_jet[17],  *_jz_save = NULL, *_jz_oneOverN=NULL,*_jz_theNs=NULL;
    static MY_FLOAT     _jz_tvar1, _jz_tvar2, _jz_tvar3, _jz_tvar4; /* tmp vars */
    static MY_FLOAT     _jz_uvar1, _jz_uvar2; /* tmp vars */
    static MY_FLOAT     _jz_svar1, _jz_svar2, _jz_svar3, _jz_svar4, _jz_svar5; /* tmp vars */
    static MY_FLOAT     _jz_wvar3, _jz_wvar4; /* tmp vars */
    static MY_FLOAT     _jz_zvar1, _jz_zvar2; /* tmp vars */
    static MY_FLOAT     _jz_MyFloatZERO, _kthtmp;
    #pragma omp threadprivate(_jz_jet, _jz_save, _jz_oneOverN, _jz_theNs, _jz_tvar1, _jz_tvar2, _jz_tvar3, _jz_tvar4, _jz_uvar1, _jz_uvar2, _jz_svar1, _jz_svar2, _jz_svar3, _jz_svar4, _jz_svar5, _jz_wvar3, _jz_wvar4, _jz_zvar1, _jz_zvar2, _jz_MyFloatZERO, _kthtmp)
/* series bgn */
    static MY_JET       *_sjz_jet[17], *_sjz_save = NULL;
    static MY_JET     _sjz_tvar1, _sjz_tvar2, _sjz_tvar3, _sjz_tvar4; /* tmp vars */
    static MY_JET     _sjz_uvar1, _sjz_uvar2; /* tmp vars */
    static MY_JET     _sjz_svar1, _sjz_svar2, _sjz_svar3, _sjz_svar4, _sjz_svar5; /* tmp vars */
    static MY_JET     _sjz_wvar3, _sjz_wvar4; /* tmp vars */
    static MY_JET     _sjz_zvar1, _sjz_zvar2; /* tmp vars */
    static MY_JET     _kthStmp; /* tmp vars */
    #pragma omp threadprivate(_sjz_jet, _sjz_save, _sjz_tvar1, _sjz_tvar2, _sjz_tvar3, _sjz_tvar4, _sjz_uvar1, _sjz_uvar2, _sjz_svar1, _sjz_svar2, _sjz_svar3, _sjz_svar4, _sjz_svar5,  _sjz_wvar3, _sjz_wvar4, _sjz_zvar1, _sjz_zvar2, _kthStmp)
/* series end */
    static int          _jz_maxOrderUsed  = -1;
    static int          _jz_lastOrder = 0, _jz_initialized=0, _jz_ginitialized=0;
    int                 _jz_i, _jz_j, _jz_k, _jz_l, _jz_m, _jz_n, _jz_oorder ;
    #pragma omp threadprivate(_jz_maxOrderUsed,_jz_lastOrder, _jz_initialized, _jz_ginitialized)
    /* allocating memory if needed */
    if (_jz_maxOrderUsed < order )  { 
    	 if (_jz_ginitialized == 0) { 
    	   InitMyFloat(_jz_tvar1); InitMyFloat(_jz_tvar2);InitMyFloat(_jz_tvar3);InitMyFloat(_jz_tvar4);
    	   InitMyFloat(_jz_svar1); InitMyFloat(_jz_svar2);InitMyFloat(_jz_svar3);InitMyFloat(_jz_svar4);
    	   InitMyFloat(_jz_svar5); InitMyFloat(_jz_zvar1);InitMyFloat(_jz_zvar2);
    	   InitMyFloat(_jz_uvar1); InitMyFloat(_jz_uvar2);
    	   InitMyFloat(_jz_wvar3);InitMyFloat(_jz_wvar4);
    	   InitMyFloat(_jz_MyFloatZERO); InitMyFloat(_kthtmp);
    	   MakeMyFloatC(_jz_MyFloatZERO, "0", (double)0);
    	   /* series bgn */
    	   InitJet(_sjz_tvar1); InitJet(_sjz_tvar2);InitJet(_sjz_tvar3);InitJet(_sjz_tvar4);
    	   InitJet(_sjz_svar1); InitJet(_sjz_svar2);InitJet(_sjz_svar3);InitJet(_sjz_svar4);
    	   InitJet(_sjz_svar5); InitJet(_sjz_zvar1);InitJet(_sjz_zvar2);
    	   InitJet(_sjz_uvar1); InitJet(_sjz_uvar2);
    	   InitJet(_sjz_wvar3); InitJet(_sjz_wvar4);
    	   InitJet(_kthStmp);
    	   /* series end */
    	 }
    	 if (rflag > 0) rflag = 0; /* have to recompute everything */
    	 _jz_oorder=_jz_maxOrderUsed;
    	 _jz_maxOrderUsed  = order;
    	 if (_jz_ginitialized) { 
    	   for(_jz_i=0; _jz_i< _jz_oorder+1; _jz_i++) {ClearMyFloat(_jz_oneOverN[_jz_i]); ClearMyFloat(_jz_theNs[_jz_i]);}
    	   free(_jz_oneOverN); free(_jz_theNs);
    	 }
    	 _jz_theNs = (MY_FLOAT *)malloc((order+1) * sizeof(MY_FLOAT));
    	 _jz_oneOverN = (MY_FLOAT *)malloc((order+1) * sizeof(MY_FLOAT));
    	 for(_jz_i=0; _jz_i<order+1; _jz_i++) {InitMyFloat(_jz_oneOverN[_jz_i]);InitMyFloat(_jz_theNs[_jz_i]);}
    	 MakeMyFloatC(_jz_theNs[0],"0.0", (double)0.0);
    	 MakeMyFloatC(_jz_uvar1,"1.0", (double)1.0);
    	 for(_jz_i = 1; _jz_i <= order; _jz_i++) {
    		 AssignMyFloat(_jz_tvar2, _jz_theNs[_jz_i-1]);
    		 AddMyFloatA(_jz_theNs[_jz_i], _jz_tvar2, _jz_uvar1);
	}
    	 AssignMyFloat(_jz_oneOverN[0],_jz_uvar1);
    	 AssignMyFloat(_jz_oneOverN[1],_jz_uvar1);
    	 for(_jz_i = 2; _jz_i <= order; _jz_i++) {
    		 DivideMyFloatA(_jz_oneOverN[_jz_i], _jz_uvar1,_jz_theNs[_jz_i]);
	}
    	 if (_jz_ginitialized) {
    	    for(_jz_i=0; _jz_i<(_jz_oorder+1)*(17); _jz_i++) { ClearMyFloat(_jz_save[_jz_i]);} free(_jz_save);
	  /* series bgn */
    	    for(_jz_i=0; _jz_i<(_jz_oorder+1)*(17); _jz_i++) { ClearJet(_sjz_save[_jz_i]);} free(_sjz_save);
	  /* series end */
    	 }
    	 _jz_save = (MY_FLOAT *)malloc((order+1)* 17 *sizeof(MY_FLOAT));
    	 for(_jz_i=0; _jz_i<(order+1)*(17); _jz_i++) { InitMyFloat(_jz_save[_jz_i]);}
    	 for(_jz_j = 0, _jz_k = 0; _jz_j < 17 ;  _jz_j++, _jz_k += order+1) { _jz_jet[_jz_j] =& (_jz_save[_jz_k]); }
    	 /*s eries bgn */
    	 _sjz_save = (MY_JET *)malloc((order+1)* 17 *sizeof(MY_JET));
    	 for(_jz_i=0; _jz_i<(order+1)*(17); _jz_i++) { InitJet(_sjz_save[_jz_i]);}
    	 for(_jz_j = 0, _jz_k = 0; _jz_j < 17 ;  _jz_j++, _jz_k += order+1) { _sjz_jet[_jz_j] =& (_sjz_save[_jz_k]); }
    	 /* series end */

    	 /* True constants, initialized only once. */
    }

    if (rflag) {
    	 if (rflag < 0 ) return(NULL);
    	 for(_jz_i = 0; rflag != 0 && _jz_i < 3; _jz_i++) {
    		 if (MyFloatA_NEQ_B(_jz_jet[_jz_i][0], x[_jz_i])) rflag = 0;
    	 }
    }

    if (rflag == 0) {
	 /* initialize all constant vars and state variables */
	 _jz_lastOrder = 1;
		 /* init state variable: */
	 AssignFloatToJet(_sjz_jet[0][0], x[0]);
	 AssignMyFloat(_jz_jet[0][0], x[0]);
		 /* init state variable: */
	 AssignFloatToJet(_sjz_jet[1][0], x[1]);
	 AssignMyFloat(_jz_jet[1][0], x[1]);
		 /* init state variable: */
	 AssignFloatToJet(_sjz_jet[2][0], x[2]);
	 AssignMyFloat(_jz_jet[2][0], x[2]);
/* series bgn */
	 if (sIn){
		 AssignJetToJet(_sjz_jet[0][0], sIn[0]);
		 AssignJetToFloat(_jz_jet[0][0], sIn[0]);
		 AssignJetToJet(_sjz_jet[1][0], sIn[1]);
		 AssignJetToFloat(_jz_jet[1][0], sIn[1]);
		 AssignJetToJet(_sjz_jet[2][0], sIn[2]);
		 AssignJetToFloat(_jz_jet[2][0], sIn[2]);
	 }
/* series end */
	 /* mult: v_011=(v_004*v_005) */
	 MultiplyJetJetA(_sjz_jet[3][0], _sjz_jet[0][0], _sjz_jet[1][0]);
	 /* minus: v_012=(v_005-v_011) */
	 SubtractJetJetA(_sjz_jet[4][0], _sjz_jet[1][0], _sjz_jet[3][0]);
	 /* plus: v_013=(v_004+v_012) */
	 AddJetJetA(_sjz_jet[5][0], _sjz_jet[0][0], _sjz_jet[4][0]);
	 /* mult: v_014=(q*v_004) */
	 MultiplyFloatJetA(_sjz_jet[6][0], q, _sjz_jet[0][0]);
	 /* mult: v_015=(v_004*v_014) */
	 MultiplyJetJetA(_sjz_jet[7][0], _sjz_jet[0][0], _sjz_jet[6][0]);
	 /* minus: v_016=(v_013-v_015) */
	 SubtractJetJetA(_sjz_jet[8][0], _sjz_jet[5][0], _sjz_jet[7][0]);
	 /* mult: v_017=(s*v_016) */
	 MultiplyFloatJetA(_sjz_jet[9][0], s, _sjz_jet[8][0]);
	 /* negate: v_018=(-v_005) */
	 NegateJetA(_sjz_jet[10][0],_sjz_jet[1][0]);
	 /* minus: v_020=(v_018-v_011) */
	 SubtractJetJetA(_sjz_jet[11][0], _sjz_jet[10][0], _sjz_jet[3][0]);
	 /* mult: v_021=(fff*v_006) */
	 MultiplyFloatJetA(_sjz_jet[12][0], fff, _sjz_jet[2][0]);
	 /* plus: v_022=(v_020+v_021) */
	 AddJetJetA(_sjz_jet[13][0], _sjz_jet[11][0], _sjz_jet[12][0]);
	 /* div: v_023=(v_022/s) */
	 DivideJetFloatA(_sjz_jet[14][0], _sjz_jet[13][0], s);
	 /* minus: v_024=(v_004-v_006) */
	 SubtractJetJetA(_sjz_jet[15][0], _sjz_jet[0][0], _sjz_jet[2][0]);
	 /* mult: v_025=(v_024*w) */
	 MultiplyJetFloatA(_sjz_jet[16][0], _sjz_jet[15][0], w);

	 /* the first derivative of state variables */
	 /* state variable 0: */
	 AssignJetToJet(_sjz_jet[0][1], _sjz_jet[9][0]);
	 AssignJetToFloat(_jz_jet[0][1], _sjz_jet[0][1]);
	 /* state variable 1: */
	 AssignJetToJet(_sjz_jet[1][1], _sjz_jet[14][0]);
	 AssignJetToFloat(_jz_jet[1][1], _sjz_jet[1][1]);
	 /* state variable 2: */
	 AssignJetToJet(_sjz_jet[2][1], _sjz_jet[16][0]);
	 AssignJetToFloat(_jz_jet[2][1], _sjz_jet[2][1]);
	}

	 /* compute the kth order derivatives of all vars */
	 for(_jz_k = _jz_lastOrder; _jz_k < order; _jz_k++) {
		 /* derivative for tmp variables */
		 /* mult: v_011=(v_004*v_005) */
		 { /* multiplication */
			 static MY_FLOAT tmp1, tmp2, tmp;
			 #pragma omp threadprivate(tmp1, tmp2, tmp)
			 static MY_JET stmp1, stmp2, stmp;
			 #pragma omp threadprivate(stmp1, stmp2, stmp)
			 if(_jz_initialized==0) {
			   InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			   InitJet(stmp1);InitJet(stmp2); InitJet(stmp);
			   }
			 AssignFloatToJet(stmp, _jz_MyFloatZERO);
			 for(_jz_l=0; _jz_l<=_jz_k; _jz_l++) {
			     MultiplyJetJetA(stmp1, _sjz_jet[0][_jz_l], _sjz_jet[1][_jz_k-_jz_l]);
			     AssignJetToJet(stmp2, stmp);
			     AddJetJetA(stmp, stmp2, stmp1);
			 }
			 AssignJetToJet(_sjz_jet[3][_jz_k], stmp);
		 }
		 /* minus: v_012=(v_005-v_011) */
		 SubtractJetJetA(_sjz_jet[4][_jz_k], _sjz_jet[1][_jz_k],_sjz_jet[3][_jz_k]);
		 /* plus: v_013=(v_004+v_012) */
		 AddJetJetA(_sjz_jet[5][_jz_k], _sjz_jet[0][_jz_k],_sjz_jet[4][_jz_k]);
		 /* mult: v_014=(q*v_004) */
		 MultiplyFloatJetA(_sjz_jet[6][_jz_k], q, _sjz_jet[0][_jz_k]);
		 /* mult: v_015=(v_004*v_014) */
		 { /* multiplication */
			 static MY_FLOAT tmp1, tmp2, tmp;
			 #pragma omp threadprivate(tmp1, tmp2, tmp)
			 static MY_JET stmp1, stmp2, stmp;
			 #pragma omp threadprivate(stmp1, stmp2, stmp)
			 if(_jz_initialized==0) {
			   InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			   InitJet(stmp1);InitJet(stmp2); InitJet(stmp);
			   }
			 AssignFloatToJet(stmp, _jz_MyFloatZERO);
			 for(_jz_l=0; _jz_l<=_jz_k; _jz_l++) {
			     MultiplyJetJetA(stmp1, _sjz_jet[0][_jz_l], _sjz_jet[6][_jz_k-_jz_l]);
			     AssignJetToJet(stmp2, stmp);
			     AddJetJetA(stmp, stmp2, stmp1);
			 }
			 AssignJetToJet(_sjz_jet[7][_jz_k], stmp);
		 }
		 /* minus: v_016=(v_013-v_015) */
		 SubtractJetJetA(_sjz_jet[8][_jz_k], _sjz_jet[5][_jz_k],_sjz_jet[7][_jz_k]);
		 /* mult: v_017=(s*v_016) */
		 MultiplyFloatJetA(_sjz_jet[9][_jz_k], s, _sjz_jet[8][_jz_k]);
		 /* negation: v_018=(-v_005) */
		 NegateJetA(_sjz_jet[10][_jz_k], _sjz_jet[1][_jz_k]);
		 /* minus: v_020=(v_018-v_011) */
		 SubtractJetJetA(_sjz_jet[11][_jz_k], _sjz_jet[10][_jz_k],_sjz_jet[3][_jz_k]);
		 /* mult: v_021=(fff*v_006) */
		 MultiplyFloatJetA(_sjz_jet[12][_jz_k], fff, _sjz_jet[2][_jz_k]);
		 /* plus: v_022=(v_020+v_021) */
		 AddJetJetA(_sjz_jet[13][_jz_k], _sjz_jet[11][_jz_k],_sjz_jet[12][_jz_k]);
		 /* div: v_023=(v_022/s) */
		 DivideJetFloatA(_sjz_jet[14][_jz_k], _sjz_jet[13][_jz_k], s);
		 /* minus: v_024=(v_004-v_006) */
		 SubtractJetJetA(_sjz_jet[15][_jz_k], _sjz_jet[0][_jz_k],_sjz_jet[2][_jz_k]);
		 /* mult: v_025=(v_024*w) */
		 MultiplyJetFloatA(_sjz_jet[16][_jz_k], _sjz_jet[15][_jz_k], w);
		 /* derivative of state variables */
		 _jz_m = _jz_k+1;
		 /* state variable 0: */
		 DivideJetFloatA(_sjz_jet[0][_jz_m], _sjz_jet[9][_jz_k], _jz_theNs[_jz_m]);
		 AssignJetToFloat(_jz_jet[0][_jz_m], _sjz_jet[0][_jz_m]);
		 /* state variable 1: */
		 DivideJetFloatA(_sjz_jet[1][_jz_m], _sjz_jet[14][_jz_k], _jz_theNs[_jz_m]);
		 AssignJetToFloat(_jz_jet[1][_jz_m], _sjz_jet[1][_jz_m]);
		 /* state variable 2: */
		 DivideJetFloatA(_sjz_jet[2][_jz_m], _sjz_jet[16][_jz_k], _jz_theNs[_jz_m]);
		 AssignJetToFloat(_jz_jet[2][_jz_m], _sjz_jet[2][_jz_m]);
		 _jz_initialized=1;
	 }
    _jz_lastOrder = order;
    _jz_ginitialized=1;
    if (sOut) {
     *sOut = _sjz_jet;
    }
    return(_jz_jet);
}

MY_FLOAT **taylor_coefficients_taylorA(MY_FLOAT t, MY_FLOAT *x, int order, int rflag)
{
    return(taylor_coefficients_taylor_A(t,x,order,rflag, NULL, NULL));
}

MY_FLOAT **taylor_coefficients_taylor(MY_FLOAT t, MY_FLOAT *x, int order)
{
    return(taylor_coefficients_taylorA(t,x,order,0));
}

#ifndef _JET_IO_HELPERS_
#define _JET_IO_HELPERS_


static const char *ode_variable_names[]={ "x", "y", "z", NULL };

static const char *jet_variable_monomials[]={

"s1","s2","s3",

NULL

};

#if _MAX_SIZE_OF_JET_VAR_ > 1

#include <stdio.h>
#include <ctype.h>
#include <string.h>

/*
 *  Jet IO Helpers.  These helpers assumes the jet libraries
 *  order the monomials using the lexicographical order. I.e, a
 *  jet is repesent as
 *    a0 + a1 s_1 + a2 s_2 + a3 s_3 + a4 s1^2 + a5 s1 s2 + a6 s1 s3 + a7 s2^2 + a8 s2 s3 + a9 s3^2 ...
 */

static char *get_next_number(const char *s, int *j, char *buf) {
  const char *p=s + *j;
  int i=0, k=0;
  while(p && *p && (!isdigit(*p)) && *p != '.' && *p != '-') {    k++; p++;  }
  while(p && *p && (isdigit(*p) || *p == '.' || *p == '-')) {  
    buf[i++] = *p++; k++;
  }
  buf[i++] = '\0';
  *j = *j+k;
  return buf;
}
static char *get_next_number_stdin(char *buf) {
  int i=0; char p = getc(stdin);
  while(p && (!isdigit(p)) && p != '.' && p != '-') { p = getc(stdin);  }
  while(p && (isdigit(p) || p == '.' || p == '-')) { buf[i++] = p; p = getc(stdin);}
  buf[i++] = '\0'; return buf;
}


static int taylor_gen_jetvar_prompt(int i, char *buf) {
  /* extern char *ode_variable_names[], *jet_variable_monomials[];  */
  
  const char *me = ode_variable_names[i];
  char tmp[128]; 
  int j;

  sprintf(buf, "%s", me);
  j = 0;
  while(jet_variable_monomials[j] != NULL) {
    sprintf(tmp, ",%s", jet_variable_monomials[j]);
    (void)strcat(buf, tmp);
    j++;
  }
  return j+1;
}

/* 
 *  create jet var from an array of doubles
 *  Parms:  a, JET var
 *          values, an array of doubles assign to jet
 *                  caller needs to make sure there are  
 *                  enough number in values
 */

int taylor_make_jet(MY_JET a, MY_COEF *mycoefs, MY_FLOAT *myfloats, double *values) {
  int i;
  MY_COEF *dtmp = (MY_COEF *) malloc((_MAX_SIZE_OF_JET_VAR_) * sizeof(MY_COEF));
  if (dtmp == NULL) {
    fprintf(stderr, "Unable to allocate %d bytes.", (int) ( (_MAX_SIZE_OF_JET_VAR_) * sizeof(MY_COEF)));
    fflush(stderr); exit(9);
  }
  if (mycoefs != NULL) {
    for (i = 0; i < _MAX_SIZE_OF_JET_VAR_; i++) {
      mycoef_init(dtmp[i]);
      mycoef_set(dtmp[i],mycoefs[i]);
    }
  } else if (myfloats != NULL) {
    for (i = 0; i < _MAX_SIZE_OF_JET_VAR_; i++) {
      mycoef_init(dtmp[i]);
      mycoef_set_myfloat(dtmp[i],myfloats[i]);
    }
  } else if(values != NULL) {
    for (i = 0; i < _MAX_SIZE_OF_JET_VAR_; i++) {
      mycoef_init(dtmp[i]);
      mycoef_set_d(dtmp[i],values[i]);
    }
  }
  // The monomials solicited here are in lexical order. We need to
  // make sure our assigment macro/function are using the matching
  // order
  MY_JET_FUN(set_coef_array)(a,dtmp);
  for(i = 0; i < _MAX_SIZE_OF_JET_VAR_; i++) {
    mycoef_clean(dtmp[i]);
  }
  (void)free(dtmp);
  return 0;
}

/*
 *  Make an identity jet. If values is give, set the value of the
 *  state variables. Otherwise, leave the state variable alone.
 */

int taylor_make_identity_jets(MY_JET *inOut, MY_COEF *mycoefs, MY_FLOAT *myfloats, double *values) {
  int i,j, k;

  k = _NUMBER_OF_JET_VARS_ > _NUMBER_OF_MAX_SYMBOLS_ ? _NUMBER_OF_MAX_SYMBOLS_ : _NUMBER_OF_JET_VARS_;
  
  for(i = 0; i < k; i++) {
    for (j = 0; j < _MAX_SIZE_OF_JET_VAR_; j++) {
      if (j == 0 ) {
        if (mycoefs != NULL) {
          mycoef_set(MY_JET_DATA((inOut[i]),0),mycoefs[i]);
        } else if(myfloats != NULL) {
          mycoef_set_myfloat(MY_JET_DATA((inOut[i]),0),myfloats[i]);
	} else if( values != NULL) {
          mycoef_set_d(MY_JET_DATA((inOut[i]),0),values[i]);
	}
      } else {
	if(i == j-1) { // offset by 1.
          mycoef_set_si( MY_JET_DATA((inOut[i]),j),1);
	} else {
          mycoef_set_si( MY_JET_DATA((inOut[i]),j),0);
	}
      }
    }
  }
  for (i = k; i < _NUMBER_OF_STATE_VARS_; i++) {
    for (j = 0; j < _MAX_SIZE_OF_JET_VAR_; j++) {
      if (j == 0) {
        if (mycoefs != NULL) {
           mycoef_set(MY_JET_DATA((inOut[i]),0),mycoefs[i]);
        } else if (myfloats != NULL) {
          mycoef_set_myfloat(MY_JET_DATA((inOut[i]),0),myfloats[i]);
        } else if (values != NULL) {	
          mycoef_set_d(MY_JET_DATA((inOut[i]),0),values[i]);
        } else {
          mycoef_set_si(MY_JET_DATA((inOut[i]),0),0);
        }
      } else {
        mycoef_set_si( MY_JET_DATA((inOut[i]),j),0);
      }
    }
  }
  return 0;
}

/*
 *   make an unit jet
 *     jet = v + s_idx
 *   idx is 0 based, s0, s1, s2 etc. 
 */
int taylor_make_unit_jet(MY_JET a, int idx, MY_COEF *mycoef, MY_FLOAT *myfloat, double *value) {
  for (int j = 0; j < _MAX_SIZE_OF_JET_VAR_; j++) {
    if (j == 0) {
      if (mycoef != NULL) {
        mycoef_set(MY_JET_DATA((a),0),*mycoef);
      } if (myfloat != NULL) {
        mycoef_set_myfloat(MY_JET_DATA((a),0),*myfloat);
      } else if(value != NULL) {
        mycoef_set_d(MY_JET_DATA((a),0),*value);
      }
    } else {
      if (j == idx+1) {
        mycoef_set_si(MY_JET_DATA((a),j),1);
      } else {
        mycoef_set_si(MY_JET_DATA((a),j),0);
      }
    }
  }
  return 0;
}


/*
 *  Set the value of jet using an array of MY_FLOATs.
 *  optionally set the state variable. 
 */
int taylor_set_jet(MY_JET a, MY_COEF *mycoefs, MY_FLOAT *myfloats, double *values, int include_state) {
  int j, offset = 1;
  if (include_state) offset = 0;
  else {mycoef_set_si( MY_JET_DATA((a),0),0);}
  
  if (mycoefs != NULL) {
    for(j = offset; j < _MAX_SIZE_OF_JET_VAR_; j++) {
      mycoef_set( MY_JET_DATA((a),j),mycoefs[j-offset]);
    }
  } else if (myfloats != NULL) {
    for(j = offset; j < _MAX_SIZE_OF_JET_VAR_; j++) {
      mycoef_set_myfloat( MY_JET_DATA((a),j),myfloats[j-offset]);
    }
  } else if (values != NULL) {
    for(j = offset; j < _MAX_SIZE_OF_JET_VAR_; j++) {
      mycoef_set_d( MY_JET_DATA((a),j),values[j-offset]);
    }
  }
  return 0;
}

/*
 *  Output a jet to an array of MY_FLOATs, optionally include
 *  the state variable.
 */
MY_COEF *taylor_convert_jet_to_array(MY_JET a, int include_state) {
  int i,offset = 1;
  if (include_state) offset = 0;
  
  static MY_COEF *dtmp = NULL;
#pragma omp threadprivate(dtmp)
  
  if(dtmp == NULL) {
    dtmp = (MY_COEF *) malloc((_MAX_SIZE_OF_JET_VAR_) * sizeof(MY_COEF));
    if(dtmp == NULL) {
      fprintf(stderr, "Unable to allocate %d bytes.", (int) ( (_MAX_SIZE_OF_JET_VAR_) * sizeof(MY_COEF)));
      fflush(stderr); exit(9);
    }
    for(i = 0; i < _MAX_SIZE_OF_JET_VAR_; i++) {
      mycoef_init(dtmp[i]);
      mycoef_set_si(dtmp[i], 0);
    }
  }
  for(i = offset; i < _MAX_SIZE_OF_JET_VAR_; i++) {
    mycoef_set(dtmp[i-offset],  MY_JET_DATA((a),i));
  }
  return dtmp;
}


/*
 *  taylor_input_jet: input jet from stdin,  prompt with list of monomials in jet var
 *
 *  Parms:  a, JET var
 *          idx, index of a in Jet Array. The order
 *             of the Jet Array is affixed with the
 *             order of LHS of ODEs 
 *          values, an array of doubles assign to jet
 *                  caller needs to make sure there are  
 *                  enough number in values
 */

int taylor_input_jet_from_stdin(MY_JET a, int idx) {
  /* extern char *ode_variable_names[]; */
  char buf[2048];
  int i, count, nbytes;

  MY_FLOAT *dtmp = (MY_FLOAT *)malloc((_MAX_SIZE_OF_JET_VAR_) * sizeof(MY_FLOAT));
  if(dtmp == NULL) {
    fprintf(stderr, "Unable to allocate %d bytes.", (int) ( (_MAX_SIZE_OF_JET_VAR_) * sizeof(MY_FLOAT)));
    exit(9);
  }
  for(i = 0; i < _MAX_SIZE_OF_JET_VAR_; i++) {
    InitMyFloat(dtmp[i]);
  }
  
  bzero(buf, 2048);
  count = taylor_gen_jetvar_prompt(idx, buf);

  fprintf(stderr, "Enter values for JET Var %s: %s \n", ode_variable_names[idx], buf);
  buf[0] =0;
  for(i = 0; i < _MAX_SIZE_OF_JET_VAR_; i++) {
    char *q = get_next_number_stdin(buf);
    double f = atof(q);
    MakeMyFloatC(dtmp[i], buf, f);    
  }
  
  taylor_make_jet(a, NULL, dtmp, NULL);
  
  for(i = 0; i < _MAX_SIZE_OF_JET_VAR_; i++) {
    ClearMyFloat(dtmp[i]);
  }
  (void) free(dtmp);

  return 0;
}

int taylor_input_jet_from_string(MY_JET a, const char *str) {
  static char buf[256];
  static MY_FLOAT *dtmp = NULL;  
#pragma omp threadprivate(buf,dtmp)
  int i, j=0;
  if(dtmp == NULL) {
    dtmp = (MY_FLOAT *)malloc((_MAX_SIZE_OF_JET_VAR_) * sizeof(MY_FLOAT));
    if(dtmp == NULL) {
      fprintf(stderr, "Unable to allocate %d bytes.", (int) ( (_MAX_SIZE_OF_JET_VAR_) * sizeof(MY_FLOAT)));
      exit(9);
    }
    for(i = 0; i < _MAX_SIZE_OF_JET_VAR_; i++) {
      InitMyFloat(dtmp[i]);
      MakeMyFloatA(dtmp[i], 0.0);
    }
  }
  for(i=0; i< _MAX_SIZE_OF_JET_VAR_; i++) {
    get_next_number(str, &j, buf);
    double f=atof(buf);
    MakeMyFloatC(dtmp[i], buf, f);
  }

  taylor_make_jet(a, NULL, dtmp, NULL);
  return 0;
}

int taylor_output_jet(FILE *file, const char *fmt, MY_JET a) {
  OutputJet2File(file,fmt,a);
}

void taylor_initialize_jet_library2(int nsymbs, int degree) {
  InitUpJet2(nsymbs, degree);
}
void taylor_initialize_jet_library(void) {
  InitUpJet();
}

void taylor_initialize_jet_variable(MY_JET *jet) {
  InitJet(*jet);
}

void taylor_clear_jet_variable(MY_JET *jet) {
  ClearJet(*jet);
}
void taylor_clear_up_jet_library(void) {
  ClearUpJet();
}

int taylor_set_jet_variable_degree(int deg) {
  return SetJetVarDegree(deg);
}
int taylor_set_jet_variable_number_of_symbols(int nsyms) {
  return SetJetNumSymbols(nsyms);
}

const char **taylor_get_variable_names() {
  return ode_variable_names;
}

const char **taylor_get_jet_monomials() {
  return jet_variable_monomials;
}
#endif



#endif /* _JET_IO_HELPERS_ */

